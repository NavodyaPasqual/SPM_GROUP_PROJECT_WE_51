{"version":3,"file":"jspdf.umd.js","sources":["../src/libs/globalObject.js","../src/libs/console.js","../src/libs/FileSaver.js","../src/libs/rgbcolor.js","../src/libs/AtobBtoa.js","../src/libs/md5.js","../src/libs/rc4.js","../src/libs/pdfsecurity.js","../src/libs/pdfname.js","../src/jspdf.js","../src/modules/acroform.js","../src/modules/addimage.js","../src/modules/annotations.js","../src/modules/arabic.js","../src/modules/autoprint.js","../src/modules/canvas.js","../src/modules/cell.js","../src/libs/fontFace.js","../src/modules/context2d.js","../node_modules/fflate/esm/index.mjs","../src/modules/filters.js","../src/modules/fileloading.js","../src/modules/html.js","../src/modules/javascript.js","../src/modules/outline.js","../src/modules/jpeg_support.js","../src/libs/png.js","../src/modules/png_support.js","../src/libs/omggif.js","../src/libs/JPEGEncoder.js","../src/modules/gif_support.js","../src/libs/BMPDecoder.js","../src/modules/bmp_support.js","../src/libs/WebPDecoder.js","../src/modules/webp_support.js","../src/modules/rgba_support.js","../src/modules/setlanguage.js","../src/modules/split_text_to_size.js","../src/modules/standard_fonts_metrics.js","../src/modules/ttfsupport.js","../src/modules/svg.js","../src/modules/total_pages.js","../src/modules/viewerpreferences.js","../src/modules/xmp_metadata.js","../src/modules/utf8.js","../src/modules/vfs.js","../src/libs/bidiEngine.js","../src/libs/ttffont.js"],"sourcesContent":["export var globalObject = (function() {\n  return \"undefined\" !== typeof window\n    ? window\n    : \"undefined\" !== typeof global\n    ? global\n    : \"undefined\" !== typeof self\n    ? self\n    : this;\n})();\n","import { globalObject } from \"./globalObject.js\";\n\nfunction consoleLog() {\n  if (globalObject.console && typeof globalObject.console.log === \"function\") {\n    globalObject.console.log.apply(globalObject.console, arguments);\n  }\n}\n\nfunction consoleWarn(str) {\n  if (globalObject.console) {\n    if (typeof globalObject.console.warn === \"function\") {\n      globalObject.console.warn.apply(globalObject.console, arguments);\n    } else {\n      consoleLog.call(null, arguments);\n    }\n  }\n}\n\nfunction consoleError(str) {\n  if (globalObject.console) {\n    if (typeof globalObject.console.error === \"function\") {\n      globalObject.console.error.apply(globalObject.console, arguments);\n    } else {\n      consoleLog(str);\n    }\n  }\n}\nexport var console = {\n  log: consoleLog,\n  warn: consoleWarn,\n  error: consoleError\n};\n","/**\n * @license\n * FileSaver.js\n * A saveAs() FileSaver implementation.\n *\n * By Eli Grey, http://eligrey.com\n *\n * License : https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md (MIT)\n * source  : http://purl.eligrey.com/github/FileSaver.js\n */\n\nimport { globalObject as _global } from \"./globalObject.js\";\nimport { console } from \"./console.js\";\n\nfunction bom(blob, opts) {\n  if (typeof opts === \"undefined\") opts = { autoBom: false };\n  else if (typeof opts !== \"object\") {\n    console.warn(\"Deprecated: Expected third argument to be a object\");\n    opts = { autoBom: !opts };\n  }\n\n  // prepend BOM for UTF-8 XML and text/* types (including HTML)\n  // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n  if (\n    opts.autoBom &&\n    /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(\n      blob.type\n    )\n  ) {\n    return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\n  }\n  return blob;\n}\n\nfunction download(url, name, opts) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"GET\", url);\n  xhr.responseType = \"blob\";\n  xhr.onload = function() {\n    saveAs(xhr.response, name, opts);\n  };\n  xhr.onerror = function() {\n    console.error(\"could not download file\");\n  };\n  xhr.send();\n}\n\nfunction corsEnabled(url) {\n  var xhr = new XMLHttpRequest();\n  // use sync to avoid popup blocker\n  xhr.open(\"HEAD\", url, false);\n  try {\n    xhr.send();\n  } catch (e) {}\n  return xhr.status >= 200 && xhr.status <= 299;\n}\n\n// `a.click()` doesn't work for all browsers (#465)\nfunction click(node) {\n  try {\n    node.dispatchEvent(new MouseEvent(\"click\"));\n  } catch (e) {\n    var evt = document.createEvent(\"MouseEvents\");\n    evt.initMouseEvent(\n      \"click\",\n      true,\n      true,\n      window,\n      0,\n      0,\n      0,\n      80,\n      20,\n      false,\n      false,\n      false,\n      false,\n      0,\n      null\n    );\n    node.dispatchEvent(evt);\n  }\n}\n\nvar saveAs =\n  _global.saveAs ||\n  // probably in some web worker\n  (typeof window !== \"object\" || window !== _global\n    ? function saveAs() {\n        /* noop */\n      }\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a native app\n    typeof HTMLAnchorElement !== \"undefined\" &&\n      \"download\" in HTMLAnchorElement.prototype\n    ? function saveAs(blob, name, opts) {\n        var URL = _global.URL || _global.webkitURL;\n        var a = document.createElement(\"a\");\n        name = name || blob.name || \"download\";\n\n        a.download = name;\n        a.rel = \"noopener\"; // tabnabbing\n\n        // TODO: detect chrome extensions & packaged apps\n        // a.target = '_blank'\n\n        if (typeof blob === \"string\") {\n          // Support regular links\n          a.href = blob;\n          if (a.origin !== location.origin) {\n            corsEnabled(a.href)\n              ? download(blob, name, opts)\n              : click(a, (a.target = \"_blank\"));\n          } else {\n            click(a);\n          }\n        } else {\n          // Support blobs\n          a.href = URL.createObjectURL(blob);\n          setTimeout(function() {\n            URL.revokeObjectURL(a.href);\n          }, 4e4); // 40s\n          setTimeout(function() {\n            click(a);\n          }, 0);\n        }\n      }\n    : // Use msSaveOrOpenBlob as a second approach\n    \"msSaveOrOpenBlob\" in navigator\n    ? function saveAs(blob, name, opts) {\n        name = name || blob.name || \"download\";\n\n        if (typeof blob === \"string\") {\n          if (corsEnabled(blob)) {\n            download(blob, name, opts);\n          } else {\n            var a = document.createElement(\"a\");\n            a.href = blob;\n            a.target = \"_blank\";\n            setTimeout(function() {\n              click(a);\n            });\n          }\n        } else {\n          navigator.msSaveOrOpenBlob(bom(blob, opts), name);\n        }\n      }\n    : // Fallback to using FileReader and a popup\n      function saveAs(blob, name, opts, popup) {\n        // Open a popup immediately do go around popup blocker\n        // Mostly only available on user interaction and the fileReader is async so...\n        popup = popup || open(\"\", \"_blank\");\n        if (popup) {\n          popup.document.title = popup.document.body.innerText =\n            \"downloading...\";\n        }\n\n        if (typeof blob === \"string\") return download(blob, name, opts);\n\n        var force = blob.type === \"application/octet-stream\";\n        var isSafari =\n          /constructor/i.test(_global.HTMLElement) || _global.safari;\n        var isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n\n        if (\n          (isChromeIOS || (force && isSafari)) &&\n          typeof FileReader === \"object\"\n        ) {\n          // Safari doesn't allow downloading of blob URLs\n          var reader = new FileReader();\n          reader.onloadend = function() {\n            var url = reader.result;\n            url = isChromeIOS\n              ? url\n              : url.replace(/^data:[^;]*;/, \"data:attachment/file;\");\n            if (popup) popup.location.href = url;\n            else location = url;\n            popup = null; // reverse-tabnabbing #460\n          };\n          reader.readAsDataURL(blob);\n        } else {\n          var URL = _global.URL || _global.webkitURL;\n          var url = URL.createObjectURL(blob);\n          if (popup) popup.location = url;\n          else location.href = url;\n          popup = null; // reverse-tabnabbing #460\n          setTimeout(function() {\n            URL.revokeObjectURL(url);\n          }, 4e4); // 40s\n        }\n      });\n\nexport { saveAs };\n","/**\n * A class to parse color values\n * @author Stoyan Stefanov <sstoo@gmail.com>\n * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}\n * @license Use it if you like it\n */\n\nfunction RGBColor(color_string) {\n  color_string = color_string || \"\";\n  this.ok = false;\n\n  // strip any leading #\n  if (color_string.charAt(0) == \"#\") {\n    // remove # if any\n    color_string = color_string.substr(1, 6);\n  }\n\n  color_string = color_string.replace(/ /g, \"\");\n  color_string = color_string.toLowerCase();\n\n  var channels;\n\n  // before getting into regexps, try simple matches\n  // and overwrite the input\n  var simple_colors = {\n    aliceblue: \"f0f8ff\",\n    antiquewhite: \"faebd7\",\n    aqua: \"00ffff\",\n    aquamarine: \"7fffd4\",\n    azure: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"000000\",\n    blanchedalmond: \"ffebcd\",\n    blue: \"0000ff\",\n    blueviolet: \"8a2be2\",\n    brown: \"a52a2a\",\n    burlywood: \"deb887\",\n    cadetblue: \"5f9ea0\",\n    chartreuse: \"7fff00\",\n    chocolate: \"d2691e\",\n    coral: \"ff7f50\",\n    cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"00ffff\",\n    darkblue: \"00008b\",\n    darkcyan: \"008b8b\",\n    darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\",\n    darkgreen: \"006400\",\n    darkkhaki: \"bdb76b\",\n    darkmagenta: \"8b008b\",\n    darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\",\n    darkorchid: \"9932cc\",\n    darkred: \"8b0000\",\n    darksalmon: \"e9967a\",\n    darkseagreen: \"8fbc8f\",\n    darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\",\n    darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\",\n    deeppink: \"ff1493\",\n    deepskyblue: \"00bfff\",\n    dimgray: \"696969\",\n    dodgerblue: \"1e90ff\",\n    feldspar: \"d19275\",\n    firebrick: \"b22222\",\n    floralwhite: \"fffaf0\",\n    forestgreen: \"228b22\",\n    fuchsia: \"ff00ff\",\n    gainsboro: \"dcdcdc\",\n    ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\",\n    goldenrod: \"daa520\",\n    gray: \"808080\",\n    green: \"008000\",\n    greenyellow: \"adff2f\",\n    honeydew: \"f0fff0\",\n    hotpink: \"ff69b4\",\n    indianred: \"cd5c5c\",\n    indigo: \"4b0082\",\n    ivory: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavender: \"e6e6fa\",\n    lavenderblush: \"fff0f5\",\n    lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\",\n    lightblue: \"add8e6\",\n    lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\",\n    lightgoldenrodyellow: \"fafad2\",\n    lightgrey: \"d3d3d3\",\n    lightgreen: \"90ee90\",\n    lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\",\n    lightseagreen: \"20b2aa\",\n    lightskyblue: \"87cefa\",\n    lightslateblue: \"8470ff\",\n    lightslategray: \"778899\",\n    lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\",\n    lime: \"00ff00\",\n    limegreen: \"32cd32\",\n    linen: \"faf0e6\",\n    magenta: \"ff00ff\",\n    maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\",\n    mediumblue: \"0000cd\",\n    mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370d8\",\n    mediumseagreen: \"3cb371\",\n    mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\",\n    mediumturquoise: \"48d1cc\",\n    mediumvioletred: \"c71585\",\n    midnightblue: \"191970\",\n    mintcream: \"f5fffa\",\n    mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\",\n    navajowhite: \"ffdead\",\n    navy: \"000080\",\n    oldlace: \"fdf5e6\",\n    olive: \"808000\",\n    olivedrab: \"6b8e23\",\n    orange: \"ffa500\",\n    orangered: \"ff4500\",\n    orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\",\n    palegreen: \"98fb98\",\n    paleturquoise: \"afeeee\",\n    palevioletred: \"d87093\",\n    papayawhip: \"ffefd5\",\n    peachpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pink: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powderblue: \"b0e0e6\",\n    purple: \"800080\",\n    red: \"ff0000\",\n    rosybrown: \"bc8f8f\",\n    royalblue: \"4169e1\",\n    saddlebrown: \"8b4513\",\n    salmon: \"fa8072\",\n    sandybrown: \"f4a460\",\n    seagreen: \"2e8b57\",\n    seashell: \"fff5ee\",\n    sienna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyblue: \"87ceeb\",\n    slateblue: \"6a5acd\",\n    slategray: \"708090\",\n    snow: \"fffafa\",\n    springgreen: \"00ff7f\",\n    steelblue: \"4682b4\",\n    tan: \"d2b48c\",\n    teal: \"008080\",\n    thistle: \"d8bfd8\",\n    tomato: \"ff6347\",\n    turquoise: \"40e0d0\",\n    violet: \"ee82ee\",\n    violetred: \"d02090\",\n    wheat: \"f5deb3\",\n    white: \"ffffff\",\n    whitesmoke: \"f5f5f5\",\n    yellow: \"ffff00\",\n    yellowgreen: \"9acd32\"\n  };\n  color_string = simple_colors[color_string] || color_string;\n\n  // array of color definition objects\n  var color_defs = [\n    {\n      re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\n      example: [\"rgb(123, 234, 45)\", \"rgb(255,234,245)\"],\n      process: function(bits) {\n        return [parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3])];\n      }\n    },\n    {\n      re: /^(\\w{2})(\\w{2})(\\w{2})$/,\n      example: [\"#00ff00\", \"336699\"],\n      process: function(bits) {\n        return [\n          parseInt(bits[1], 16),\n          parseInt(bits[2], 16),\n          parseInt(bits[3], 16)\n        ];\n      }\n    },\n    {\n      re: /^(\\w{1})(\\w{1})(\\w{1})$/,\n      example: [\"#fb0\", \"f0f\"],\n      process: function(bits) {\n        return [\n          parseInt(bits[1] + bits[1], 16),\n          parseInt(bits[2] + bits[2], 16),\n          parseInt(bits[3] + bits[3], 16)\n        ];\n      }\n    }\n  ];\n\n  // search through the definitions to find a match\n  for (var i = 0; i < color_defs.length; i++) {\n    var re = color_defs[i].re;\n    var processor = color_defs[i].process;\n    var bits = re.exec(color_string);\n    if (bits) {\n      channels = processor(bits);\n      this.r = channels[0];\n      this.g = channels[1];\n      this.b = channels[2];\n      this.ok = true;\n    }\n  }\n\n  // validate/cleanup values\n  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;\n  this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;\n  this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;\n\n  // some getters\n  this.toRGB = function() {\n    return \"rgb(\" + this.r + \", \" + this.g + \", \" + this.b + \")\";\n  };\n  this.toHex = function() {\n    var r = this.r.toString(16);\n    var g = this.g.toString(16);\n    var b = this.b.toString(16);\n    if (r.length == 1) r = \"0\" + r;\n    if (g.length == 1) g = \"0\" + g;\n    if (b.length == 1) b = \"0\" + b;\n    return \"#\" + r + g + b;\n  };\n}\n\nexport { RGBColor };\n","import { globalObject } from \"./globalObject.js\";\n\nvar atob, btoa;\n\n(function() {\n  atob = globalObject.atob.bind(globalObject);\n  btoa = globalObject.btoa.bind(globalObject);\n  return;\n\n})();\n\nexport { atob, btoa };\n","/**\n * @license\n * Joseph Myers does not specify a particular license for his work.\n *\n * Author: Joseph Myers\n * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js\n *\n * Modified by: Owen Leong\n */\n\nfunction md5cycle(x, k) {\n  var a = x[0],\n    b = x[1],\n    c = x[2],\n    d = x[3];\n\n  a = ff(a, b, c, d, k[0], 7, -680876936);\n  d = ff(d, a, b, c, k[1], 12, -389564586);\n  c = ff(c, d, a, b, k[2], 17, 606105819);\n  b = ff(b, c, d, a, k[3], 22, -1044525330);\n  a = ff(a, b, c, d, k[4], 7, -176418897);\n  d = ff(d, a, b, c, k[5], 12, 1200080426);\n  c = ff(c, d, a, b, k[6], 17, -1473231341);\n  b = ff(b, c, d, a, k[7], 22, -45705983);\n  a = ff(a, b, c, d, k[8], 7, 1770035416);\n  d = ff(d, a, b, c, k[9], 12, -1958414417);\n  c = ff(c, d, a, b, k[10], 17, -42063);\n  b = ff(b, c, d, a, k[11], 22, -1990404162);\n  a = ff(a, b, c, d, k[12], 7, 1804603682);\n  d = ff(d, a, b, c, k[13], 12, -40341101);\n  c = ff(c, d, a, b, k[14], 17, -1502002290);\n  b = ff(b, c, d, a, k[15], 22, 1236535329);\n\n  a = gg(a, b, c, d, k[1], 5, -165796510);\n  d = gg(d, a, b, c, k[6], 9, -1069501632);\n  c = gg(c, d, a, b, k[11], 14, 643717713);\n  b = gg(b, c, d, a, k[0], 20, -373897302);\n  a = gg(a, b, c, d, k[5], 5, -701558691);\n  d = gg(d, a, b, c, k[10], 9, 38016083);\n  c = gg(c, d, a, b, k[15], 14, -660478335);\n  b = gg(b, c, d, a, k[4], 20, -405537848);\n  a = gg(a, b, c, d, k[9], 5, 568446438);\n  d = gg(d, a, b, c, k[14], 9, -1019803690);\n  c = gg(c, d, a, b, k[3], 14, -187363961);\n  b = gg(b, c, d, a, k[8], 20, 1163531501);\n  a = gg(a, b, c, d, k[13], 5, -1444681467);\n  d = gg(d, a, b, c, k[2], 9, -51403784);\n  c = gg(c, d, a, b, k[7], 14, 1735328473);\n  b = gg(b, c, d, a, k[12], 20, -1926607734);\n\n  a = hh(a, b, c, d, k[5], 4, -378558);\n  d = hh(d, a, b, c, k[8], 11, -2022574463);\n  c = hh(c, d, a, b, k[11], 16, 1839030562);\n  b = hh(b, c, d, a, k[14], 23, -35309556);\n  a = hh(a, b, c, d, k[1], 4, -1530992060);\n  d = hh(d, a, b, c, k[4], 11, 1272893353);\n  c = hh(c, d, a, b, k[7], 16, -155497632);\n  b = hh(b, c, d, a, k[10], 23, -1094730640);\n  a = hh(a, b, c, d, k[13], 4, 681279174);\n  d = hh(d, a, b, c, k[0], 11, -358537222);\n  c = hh(c, d, a, b, k[3], 16, -722521979);\n  b = hh(b, c, d, a, k[6], 23, 76029189);\n  a = hh(a, b, c, d, k[9], 4, -640364487);\n  d = hh(d, a, b, c, k[12], 11, -421815835);\n  c = hh(c, d, a, b, k[15], 16, 530742520);\n  b = hh(b, c, d, a, k[2], 23, -995338651);\n\n  a = ii(a, b, c, d, k[0], 6, -198630844);\n  d = ii(d, a, b, c, k[7], 10, 1126891415);\n  c = ii(c, d, a, b, k[14], 15, -1416354905);\n  b = ii(b, c, d, a, k[5], 21, -57434055);\n  a = ii(a, b, c, d, k[12], 6, 1700485571);\n  d = ii(d, a, b, c, k[3], 10, -1894986606);\n  c = ii(c, d, a, b, k[10], 15, -1051523);\n  b = ii(b, c, d, a, k[1], 21, -2054922799);\n  a = ii(a, b, c, d, k[8], 6, 1873313359);\n  d = ii(d, a, b, c, k[15], 10, -30611744);\n  c = ii(c, d, a, b, k[6], 15, -1560198380);\n  b = ii(b, c, d, a, k[13], 21, 1309151649);\n  a = ii(a, b, c, d, k[4], 6, -145523070);\n  d = ii(d, a, b, c, k[11], 10, -1120210379);\n  c = ii(c, d, a, b, k[2], 15, 718787259);\n  b = ii(b, c, d, a, k[9], 21, -343485551);\n\n  x[0] = add32(a, x[0]);\n  x[1] = add32(b, x[1]);\n  x[2] = add32(c, x[2]);\n  x[3] = add32(d, x[3]);\n}\n\nfunction cmn(q, a, b, x, s, t) {\n  a = add32(add32(a, q), add32(x, t));\n  return add32((a << s) | (a >>> (32 - s)), b);\n}\n\nfunction ff(a, b, c, d, x, s, t) {\n  return cmn((b & c) | (~b & d), a, b, x, s, t);\n}\n\nfunction gg(a, b, c, d, x, s, t) {\n  return cmn((b & d) | (c & ~d), a, b, x, s, t);\n}\n\nfunction hh(a, b, c, d, x, s, t) {\n  return cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction ii(a, b, c, d, x, s, t) {\n  return cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nfunction md51(s) {\n  // txt = '';\n  var n = s.length,\n    state = [1732584193, -271733879, -1732584194, 271733878],\n    i;\n  for (i = 64; i <= s.length; i += 64) {\n    md5cycle(state, md5blk(s.substring(i - 64, i)));\n  }\n  s = s.substring(i - 64);\n  var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  for (i = 0; i < s.length; i++)\n    tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);\n  tail[i >> 2] |= 0x80 << (i % 4 << 3);\n  if (i > 55) {\n    md5cycle(state, tail);\n    for (i = 0; i < 16; i++) tail[i] = 0;\n  }\n  tail[14] = n * 8;\n  md5cycle(state, tail);\n  return state;\n}\n\n/* there needs to be support for Unicode here,\n * unless we pretend that we can redefine the MD-5\n * algorithm for multi-byte characters (perhaps\n * by adding every four 16-bit characters and\n * shortening the sum to 32 bits). Otherwise\n * I suggest performing MD-5 as if every character\n * was two bytes--e.g., 0040 0025 = @%--but then\n * how will an ordinary MD-5 sum be matched?\n * There is no way to standardize text to something\n * like UTF-8 before transformation; speed cost is\n * utterly prohibitive. The JavaScript standard\n * itself needs to look at this: it should start\n * providing access to strings as preformed UTF-8\n * 8-bit unsigned value arrays.\n */\nfunction md5blk(s) {\n  /* I figured global was faster.   */\n  var md5blks = [],\n    i; /* Andy King said do it this way. */\n  for (i = 0; i < 64; i += 4) {\n    md5blks[i >> 2] =\n      s.charCodeAt(i) +\n      (s.charCodeAt(i + 1) << 8) +\n      (s.charCodeAt(i + 2) << 16) +\n      (s.charCodeAt(i + 3) << 24);\n  }\n  return md5blks;\n}\n\nvar hex_chr = \"0123456789abcdef\".split(\"\");\n\nfunction rhex(n) {\n  var s = \"\",\n    j = 0;\n  for (; j < 4; j++)\n    s += hex_chr[(n >> (j * 8 + 4)) & 0x0f] + hex_chr[(n >> (j * 8)) & 0x0f];\n  return s;\n}\n\nfunction hex(x) {\n  for (var i = 0; i < x.length; i++) x[i] = rhex(x[i]);\n  return x.join(\"\");\n}\n\n// Converts a 4-byte number to byte string\nfunction singleToByteString(n) {\n  return String.fromCharCode(\n    (n & 0xff) >> 0,\n    (n & 0xff00) >> 8,\n    (n & 0xff0000) >> 16,\n    (n & 0xff000000) >> 24\n  );\n}\n\n// Converts an array of numbers to a byte string\nfunction toByteString(x) {\n  return x.map(singleToByteString).join(\"\");\n}\n\n// Returns the MD5 hash as a byte string\nfunction md5Bin(s) {\n  return toByteString(md51(s));\n}\n\n// Returns MD5 hash as a hex string\nfunction md5(s) {\n  return hex(md51(s));\n}\n\nvar md5Check = md5(\"hello\") != \"5d41402abc4b2a76b9719d911017c592\";\n\nfunction add32(a, b) {\n  if (md5Check) {\n    /* if the md5Check does not match\n     the expected value, we're dealing\n     with an old browser and need\n     this function. */\n    var lsw = (a & 0xffff) + (b & 0xffff),\n      msw = (a >> 16) + (b >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xffff);\n  } else {\n    /* this function is much faster,\n    so if possible we use it. Some IEs\n    are the only ones I know of that\n    need the idiotic second function,\n    generated by an if clause.  */\n    return (a + b) & 0xffffffff;\n  }\n}\n\nexport { md5, md5Bin };\n","/**\r\n * @license\r\n * FPDF is released under a permissive license: there is no usage restriction.\r\n * You may embed it freely in your application (commercial or not), with or\r\n * without modifications.\r\n *\r\n * Reference: http://www.fpdf.org/en/script/script37.php\r\n */\r\n\r\nfunction repeat(str, num) {\r\n  return new Array(num + 1).join(str);\r\n}\r\n\r\n/**\r\n * Converts a byte string to a hex string\r\n *\r\n * @name rc4\r\n * @function\r\n * @param {string} key Byte string of encryption key\r\n * @param {string} data Byte string of data to be encrypted\r\n * @returns {string} Encrypted string\r\n */\r\nfunction rc4(key, data) {\r\n  var lastKey, lastState;\r\n  if (key !== lastKey) {\r\n    var k = repeat(key, ((256 / key.length) >> 0) + 1);\r\n    var state = [];\r\n    for (var i = 0; i < 256; i++) {\r\n      state[i] = i;\r\n    }\r\n    var j = 0;\r\n    for (var i = 0; i < 256; i++) {\r\n      var t = state[i];\r\n      j = (j + t + k.charCodeAt(i)) % 256;\r\n      state[i] = state[j];\r\n      state[j] = t;\r\n    }\r\n    lastKey = key;\r\n    lastState = state;\r\n  } else {\r\n    state = lastState;\r\n  }\r\n  var length = data.length;\r\n  var a = 0;\r\n  var b = 0;\r\n  var out = \"\";\r\n  for (var i = 0; i < length; i++) {\r\n    a = (a + 1) % 256;\r\n    t = state[a];\r\n    b = (b + t) % 256;\r\n    state[a] = state[b];\r\n    state[b] = t;\r\n    k = state[(state[a] + state[b]) % 256];\r\n    out += String.fromCharCode(data.charCodeAt(i) ^ k);\r\n  }\r\n  return out;\r\n}\r\n\r\nexport { rc4 };\r\n","/**\r\n * @license\r\n * Licensed under the MIT License.\r\n * http://opensource.org/licenses/mit-license\r\n * Author: Owen Leong (@owenl131)\r\n * Date: 15 Oct 2020\r\n * References:\r\n * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt\r\n * https://github.com/foliojs/pdfkit/blob/master/lib/security.js\r\n * http://www.fpdf.org/en/script/script37.php\r\n */\r\n\r\nimport { md5Bin } from \"./md5.js\";\r\nimport { rc4 } from \"./rc4.js\";\r\n\r\nvar permissionOptions = {\r\n  print: 4,\r\n  modify: 8,\r\n  copy: 16,\r\n  \"annot-forms\": 32\r\n};\r\n\r\n/**\r\n * Initializes encryption settings\r\n *\r\n * @name constructor\r\n * @function\r\n * @param {Array} permissions Permissions allowed for user, \"print\", \"modify\", \"copy\" and \"annot-forms\".\r\n * @param {String} userPassword Permissions apply to this user. Leaving this empty means the document\r\n *                              is not password protected but viewer has the above permissions.\r\n * @param {String} ownerPassword Owner has full functionalities to the file.\r\n * @param {String} fileId As hex string, should be same as the file ID in the trailer.\r\n * @example\r\n * var security = new PDFSecurity([\"print\"])\r\n */\r\nfunction PDFSecurity(permissions, userPassword, ownerPassword, fileId) {\r\n  this.v = 1; // algorithm 1, future work can add in more recent encryption schemes\r\n  this.r = 2; // revision 2\r\n\r\n  // set flags for what functionalities the user can access\r\n  let protection = 192;\r\n  permissions.forEach(function(perm) {\r\n    if (typeof permissionOptions.perm !== \"undefined\") {\r\n      throw new Error(\"Invalid permission: \" + perm);\r\n    }\r\n    protection += permissionOptions[perm];\r\n  });\r\n\r\n  // padding is used to pad the passwords to 32 bytes, also is hashed and stored in the final PDF\r\n  this.padding =\r\n    \"\\x28\\xBF\\x4E\\x5E\\x4E\\x75\\x8A\\x41\\x64\\x00\\x4E\\x56\\xFF\\xFA\\x01\\x08\" +\r\n    \"\\x2E\\x2E\\x00\\xB6\\xD0\\x68\\x3E\\x80\\x2F\\x0C\\xA9\\xFE\\x64\\x53\\x69\\x7A\";\r\n  let paddedUserPassword = (userPassword + this.padding).substr(0, 32);\r\n  let paddedOwnerPassword = (ownerPassword + this.padding).substr(0, 32);\r\n\r\n  this.O = this.processOwnerPassword(paddedUserPassword, paddedOwnerPassword);\r\n  this.P = -((protection ^ 255) + 1);\r\n  this.encryptionKey = md5Bin(\r\n    paddedUserPassword +\r\n      this.O +\r\n      this.lsbFirstWord(this.P) +\r\n      this.hexToBytes(fileId)\r\n  ).substr(0, 5);\r\n  this.U = rc4(this.encryptionKey, this.padding);\r\n}\r\n\r\n/**\r\n * Breaks down a 4-byte number into its individual bytes, with the least significant bit first\r\n *\r\n * @name lsbFirstWord\r\n * @function\r\n * @param {number} data 32-bit number\r\n * @returns {Array}\r\n */\r\nPDFSecurity.prototype.lsbFirstWord = function(data) {\r\n  return String.fromCharCode(\r\n    (data >> 0) & 0xff,\r\n    (data >> 8) & 0xff,\r\n    (data >> 16) & 0xff,\r\n    (data >> 24) & 0xff\r\n  );\r\n};\r\n\r\n/**\r\n * Converts a byte string to a hex string\r\n *\r\n * @name toHexString\r\n * @function\r\n * @param {String} byteString Byte string\r\n * @returns {String}\r\n */\r\nPDFSecurity.prototype.toHexString = function(byteString) {\r\n  return byteString\r\n    .split(\"\")\r\n    .map(function(byte) {\r\n      return (\"0\" + (byte.charCodeAt(0) & 0xff).toString(16)).slice(-2);\r\n    })\r\n    .join(\"\");\r\n};\r\n\r\n/**\r\n * Converts a hex string to a byte string\r\n *\r\n * @name hexToBytes\r\n * @function\r\n * @param {String} hex Hex string\r\n * @returns {String}\r\n */\r\nPDFSecurity.prototype.hexToBytes = function(hex) {\r\n  for (var bytes = [], c = 0; c < hex.length; c += 2)\r\n    bytes.push(String.fromCharCode(parseInt(hex.substr(c, 2), 16)));\r\n  return bytes.join(\"\");\r\n};\r\n\r\n/**\r\n * Computes the 'O' field in the encryption dictionary\r\n *\r\n * @name processOwnerPassword\r\n * @function\r\n * @param {String} paddedUserPassword Byte string of padded user password\r\n * @param {String} paddedOwnerPassword Byte string of padded owner password\r\n * @returns {String}\r\n */\r\nPDFSecurity.prototype.processOwnerPassword = function(\r\n  paddedUserPassword,\r\n  paddedOwnerPassword\r\n) {\r\n  let key = md5Bin(paddedOwnerPassword).substr(0, 5);\r\n  return rc4(key, paddedUserPassword);\r\n};\r\n\r\n/**\r\n * Returns an encryptor function which can take in a byte string and returns the encrypted version\r\n *\r\n * @name encryptor\r\n * @function\r\n * @param {number} objectId\r\n * @param {number} generation Not sure what this is for, you can set it to 0\r\n * @returns {Function}\r\n * @example\r\n * out(\"stream\");\r\n * encryptor = security.encryptor(object.id, 0);\r\n * out(encryptor(data));\r\n * out(\"endstream\");\r\n */\r\nPDFSecurity.prototype.encryptor = function(objectId, generation) {\r\n  let key = md5Bin(\r\n    this.encryptionKey +\r\n      String.fromCharCode(\r\n        objectId & 0xff,\r\n        (objectId >> 8) & 0xff,\r\n        (objectId >> 16) & 0xff,\r\n        generation & 0xff,\r\n        (generation >> 8) & 0xff\r\n      )\r\n  ).substr(0, 10);\r\n  return function(data) {\r\n    return rc4(key, data);\r\n  };\r\n};\r\n\r\nexport { PDFSecurity };\r\n","/**\n * Convert string to `PDF Name Object`.\n * Detail: PDF Reference 1.3 - Chapter 3.2.4 Name Object\n * @param str\n */\nfunction toPDFName(str) {\n  // eslint-disable-next-line no-control-regex\n  if (/[^\\u0000-\\u00ff]/.test(str)) {\n    // non ascii string\n    throw new Error(\n      \"Invalid PDF Name Object: \" + str + \", Only accept ASCII characters.\"\n    );\n  }\n  var result = \"\",\n    strLength = str.length;\n  for (var i = 0; i < strLength; i++) {\n    var charCode = str.charCodeAt(i);\n    if (\n      charCode < 0x21 ||\n      charCode === 0x23 /* # */ ||\n      charCode === 0x25 /* % */ ||\n      charCode === 0x28 /* ( */ ||\n      charCode === 0x29 /* ) */ ||\n      charCode === 0x2f /* / */ ||\n      charCode === 0x3c /* < */ ||\n      charCode === 0x3e /* > */ ||\n      charCode === 0x5b /* [ */ ||\n      charCode === 0x5d /* ] */ ||\n      charCode === 0x7b /* { */ ||\n      charCode === 0x7d /* } */ ||\n      charCode > 0x7e\n    ) {\n      // Char    CharCode    hexStr   paddingHexStr    Result\n      // \"\\t\"    9           9        09               #09\n      // \" \"     32          20       20               #20\n      // \"©\"     169         a9       a9               #a9\n      var hexStr = charCode.toString(16),\n        paddingHexStr = (\"0\" + hexStr).slice(-2);\n\n      result += \"#\" + paddingHexStr;\n    } else {\n      // Other ASCII printable characters between 0x21 <= X <= 0x7e\n      result += str[i];\n    }\n  }\n  return result;\n}\n\nexport { toPDFName };\n","/* eslint-disable no-console */\n\nimport { saveAs } from \"./libs/FileSaver.js\";\nimport { globalObject } from \"./libs/globalObject.js\";\nimport { RGBColor } from \"./libs/rgbcolor.js\";\nimport { btoa } from \"./libs/AtobBtoa.js\";\nimport { console } from \"./libs/console.js\";\nimport { PDFSecurity } from \"./libs/pdfsecurity.js\";\nimport { toPDFName } from \"./libs/pdfname.js\";\n/**\n * jsPDF's Internal PubSub Implementation.\n * Backward compatible rewritten on 2014 by\n * Diego Casorran, https://github.com/diegocr\n *\n * @class\n * @name PubSub\n * @ignore\n */\nfunction PubSub(context) {\n  if (typeof context !== \"object\") {\n    throw new Error(\n      \"Invalid Context passed to initialize PubSub (jsPDF-module)\"\n    );\n  }\n  var topics = {};\n\n  this.subscribe = function(topic, callback, once) {\n    once = once || false;\n    if (\n      typeof topic !== \"string\" ||\n      typeof callback !== \"function\" ||\n      typeof once !== \"boolean\"\n    ) {\n      throw new Error(\n        \"Invalid arguments passed to PubSub.subscribe (jsPDF-module)\"\n      );\n    }\n\n    if (!topics.hasOwnProperty(topic)) {\n      topics[topic] = {};\n    }\n\n    var token = Math.random().toString(35);\n    topics[topic][token] = [callback, !!once];\n\n    return token;\n  };\n\n  this.unsubscribe = function(token) {\n    for (var topic in topics) {\n      if (topics[topic][token]) {\n        delete topics[topic][token];\n        if (Object.keys(topics[topic]).length === 0) {\n          delete topics[topic];\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.publish = function(topic) {\n    if (topics.hasOwnProperty(topic)) {\n      var args = Array.prototype.slice.call(arguments, 1),\n        tokens = [];\n\n      for (var token in topics[topic]) {\n        var sub = topics[topic][token];\n        try {\n          sub[0].apply(context, args);\n        } catch (ex) {\n          if (globalObject.console) {\n            console.error(\"jsPDF PubSub Error\", ex.message, ex);\n          }\n        }\n        if (sub[1]) tokens.push(token);\n      }\n      if (tokens.length) tokens.forEach(this.unsubscribe);\n    }\n  };\n\n  this.getTopics = function() {\n    return topics;\n  };\n}\n\nfunction GState(parameters) {\n  if (!(this instanceof GState)) {\n    return new GState(parameters);\n  }\n\n  /**\n   * @name GState#opacity\n   * @type {any}\n   */\n  /**\n   * @name GState#stroke-opacity\n   * @type {any}\n   */\n  var supported = \"opacity,stroke-opacity\".split(\",\");\n  for (var p in parameters) {\n    if (parameters.hasOwnProperty(p) && supported.indexOf(p) >= 0) {\n      this[p] = parameters[p];\n    }\n  }\n  /**\n   * @name GState#id\n   * @type {string}\n   */\n  this.id = \"\"; // set by addGState()\n  /**\n   * @name GState#objectNumber\n   * @type {number}\n   */\n  this.objectNumber = -1; // will be set by putGState()\n}\n\nGState.prototype.equals = function equals(other) {\n  var ignore = \"id,objectNumber,equals\";\n  var p;\n  if (!other || typeof other !== typeof this) return false;\n  var count = 0;\n  for (p in this) {\n    if (ignore.indexOf(p) >= 0) continue;\n    if (this.hasOwnProperty(p) && !other.hasOwnProperty(p)) return false;\n    if (this[p] !== other[p]) return false;\n    count++;\n  }\n  for (p in other) {\n    if (other.hasOwnProperty(p) && ignore.indexOf(p) < 0) count--;\n  }\n  return count === 0;\n};\n\nfunction Pattern(gState, matrix) {\n  this.gState = gState;\n  this.matrix = matrix;\n\n  this.id = \"\"; // set by addPattern()\n  this.objectNumber = -1; // will be set by putPattern()\n}\n\nfunction ShadingPattern(type, coords, colors, gState, matrix) {\n  if (!(this instanceof ShadingPattern)) {\n    return new ShadingPattern(type, coords, colors, gState, matrix);\n  }\n\n  // see putPattern() for information how they are realized\n  this.type = type === \"axial\" ? 2 : 3;\n  this.coords = coords;\n  this.colors = colors;\n\n  Pattern.call(this, gState, matrix);\n}\n\nfunction TilingPattern(boundingBox, xStep, yStep, gState, matrix) {\n  if (!(this instanceof TilingPattern)) {\n    return new TilingPattern(boundingBox, xStep, yStep, gState, matrix);\n  }\n\n  this.boundingBox = boundingBox;\n  this.xStep = xStep;\n  this.yStep = yStep;\n\n  this.stream = \"\"; // set by endTilingPattern();\n\n  this.cloneIndex = 0;\n\n  Pattern.call(this, gState, matrix);\n}\n\n/**\n * Creates new jsPDF document object instance.\n * @name jsPDF\n * @class\n * @param {Object} [options] - Collection of settings initializing the jsPDF-instance\n * @param {string} [options.orientation=portrait] - Orientation of the first page. Possible values are \"portrait\" or \"landscape\" (or shortcuts \"p\" or \"l\").<br />\n * @param {string} [options.unit=mm] Measurement unit (base unit) to be used when coordinates are specified.<br />\n * Possible values are \"pt\" (points), \"mm\", \"cm\", \"in\", \"px\", \"pc\", \"em\" or \"ex\". Note that in order to get the correct scaling for \"px\"\n * units, you need to enable the hotfix \"px_scaling\" by setting options.hotfixes = [\"px_scaling\"].\n * @param {string/Array} [options.format=a4] The format of the first page. Can be:<ul><li>a0 - a10</li><li>b0 - b10</li><li>c0 - c10</li><li>dl</li><li>letter</li><li>government-letter</li><li>legal</li><li>junior-legal</li><li>ledger</li><li>tabloid</li><li>credit-card</li></ul><br />\n * Default is \"a4\". If you want to use your own format just pass instead of one of the above predefined formats the size as an number-array, e.g. [595.28, 841.89]\n * @param {boolean} [options.putOnlyUsedFonts=false] Only put fonts into the PDF, which were used.\n * @param {boolean} [options.compress=false] Compress the generated PDF.\n * @param {number} [options.precision=16] Precision of the element-positions.\n * @param {number} [options.userUnit=1.0] Not to be confused with the base unit. Please inform yourself before you use it.\n * @param {string[]} [options.hotfixes] An array of strings to enable hotfixes such as correct pixel scaling.\n * @param {Object} [options.encryption]\n * @param {string} [options.encryption.userPassword] Password for the user bound by the given permissions list.\n * @param {string} [options.encryption.ownerPassword] Both userPassword and ownerPassword should be set for proper authentication.\n * @param {string[]} [options.encryption.userPermissions] Array of permissions \"print\", \"modify\", \"copy\", \"annot-forms\", accessible by the user.\n * @param {number|\"smart\"} [options.floatPrecision=16]\n * @returns {jsPDF} jsPDF-instance\n * @description\n * ```\n * {\n *  orientation: 'p',\n *  unit: 'mm',\n *  format: 'a4',\n *  putOnlyUsedFonts:true,\n *  floatPrecision: 16 // or \"smart\", default is 16\n * }\n * ```\n *\n * @constructor\n */\nfunction jsPDF(options) {\n  var orientation = typeof arguments[0] === \"string\" ? arguments[0] : \"p\";\n  var unit = arguments[1];\n  var format = arguments[2];\n  var compressPdf = arguments[3];\n  var filters = [];\n  var userUnit = 1.0;\n  var precision;\n  var floatPrecision = 16;\n  var defaultPathOperation = \"S\";\n  var encryptionOptions = null;\n\n  options = options || {};\n\n  if (typeof options === \"object\") {\n    orientation = options.orientation;\n    unit = options.unit || unit;\n    format = options.format || format;\n    compressPdf = options.compress || options.compressPdf || compressPdf;\n    encryptionOptions = options.encryption || null;\n    if (encryptionOptions !== null) {\n      encryptionOptions.userPassword = encryptionOptions.userPassword || \"\";\n      encryptionOptions.ownerPassword = encryptionOptions.ownerPassword || \"\";\n      encryptionOptions.userPermissions =\n        encryptionOptions.userPermissions || [];\n    }\n    userUnit =\n      typeof options.userUnit === \"number\" ? Math.abs(options.userUnit) : 1.0;\n    if (typeof options.precision !== \"undefined\") {\n      precision = options.precision;\n    }\n    if (typeof options.floatPrecision !== \"undefined\") {\n      floatPrecision = options.floatPrecision;\n    }\n    defaultPathOperation = options.defaultPathOperation || \"S\";\n  }\n\n  filters =\n    options.filters || (compressPdf === true ? [\"FlateEncode\"] : filters);\n\n  unit = unit || \"mm\";\n  orientation = (\"\" + (orientation || \"P\")).toLowerCase();\n  var putOnlyUsedFonts = options.putOnlyUsedFonts || false;\n  var usedFonts = {};\n\n  var API = {\n    internal: {},\n    __private__: {}\n  };\n\n  API.__private__.PubSub = PubSub;\n\n  var pdfVersion = \"1.3\";\n  var getPdfVersion = (API.__private__.getPdfVersion = function() {\n    return pdfVersion;\n  });\n\n  API.__private__.setPdfVersion = function(value) {\n    pdfVersion = value;\n  };\n\n  // Size in pt of various paper formats\n  var pageFormats = {\n    a0: [2383.94, 3370.39],\n    a1: [1683.78, 2383.94],\n    a2: [1190.55, 1683.78],\n    a3: [841.89, 1190.55],\n    a4: [595.28, 841.89],\n    a5: [419.53, 595.28],\n    a6: [297.64, 419.53],\n    a7: [209.76, 297.64],\n    a8: [147.4, 209.76],\n    a9: [104.88, 147.4],\n    a10: [73.7, 104.88],\n    b0: [2834.65, 4008.19],\n    b1: [2004.09, 2834.65],\n    b2: [1417.32, 2004.09],\n    b3: [1000.63, 1417.32],\n    b4: [708.66, 1000.63],\n    b5: [498.9, 708.66],\n    b6: [354.33, 498.9],\n    b7: [249.45, 354.33],\n    b8: [175.75, 249.45],\n    b9: [124.72, 175.75],\n    b10: [87.87, 124.72],\n    c0: [2599.37, 3676.54],\n    c1: [1836.85, 2599.37],\n    c2: [1298.27, 1836.85],\n    c3: [918.43, 1298.27],\n    c4: [649.13, 918.43],\n    c5: [459.21, 649.13],\n    c6: [323.15, 459.21],\n    c7: [229.61, 323.15],\n    c8: [161.57, 229.61],\n    c9: [113.39, 161.57],\n    c10: [79.37, 113.39],\n    dl: [311.81, 623.62],\n    letter: [612, 792],\n    \"government-letter\": [576, 756],\n    legal: [612, 1008],\n    \"junior-legal\": [576, 360],\n    ledger: [1224, 792],\n    tabloid: [792, 1224],\n    \"credit-card\": [153, 243]\n  };\n\n  API.__private__.getPageFormats = function() {\n    return pageFormats;\n  };\n\n  var getPageFormat = (API.__private__.getPageFormat = function(value) {\n    return pageFormats[value];\n  });\n\n  format = format || \"a4\";\n\n  var ApiMode = {\n    COMPAT: \"compat\",\n    ADVANCED: \"advanced\"\n  };\n  var apiMode = ApiMode.COMPAT;\n\n  function advancedAPI() {\n    // prepend global change of basis matrix\n    // (Now, instead of converting every coordinate to the pdf coordinate system, we apply a matrix\n    // that does this job for us (however, texts, images and similar objects must be drawn bottom up))\n    this.saveGraphicsState();\n    out(\n      new Matrix(\n        scaleFactor,\n        0,\n        0,\n        -scaleFactor,\n        0,\n        getPageHeight() * scaleFactor\n      ).toString() + \" cm\"\n    );\n    this.setFontSize(this.getFontSize() / scaleFactor);\n\n    // The default in MrRio's implementation is \"S\" (stroke), whereas the default in the yWorks implementation\n    // was \"n\" (none). Although this has nothing to do with transforms, we should use the API switch here.\n    defaultPathOperation = \"n\";\n\n    apiMode = ApiMode.ADVANCED;\n  }\n\n  function compatAPI() {\n    this.restoreGraphicsState();\n    defaultPathOperation = \"S\";\n    apiMode = ApiMode.COMPAT;\n  }\n\n  /**\n   * @function combineFontStyleAndFontWeight\n   * @param {string} fontStyle Fontstyle or variant. Example: \"italic\".\n   * @param {number | string} fontWeight Weight of the Font. Example: \"normal\" | 400\n   * @returns {string}\n   * @private\n   */\n  var combineFontStyleAndFontWeight = (API.__private__.combineFontStyleAndFontWeight = function(\n    fontStyle,\n    fontWeight\n  ) {\n    if (\n      (fontStyle == \"bold\" && fontWeight == \"normal\") ||\n      (fontStyle == \"bold\" && fontWeight == 400) ||\n      (fontStyle == \"normal\" && fontWeight == \"italic\") ||\n      (fontStyle == \"bold\" && fontWeight == \"italic\")\n    ) {\n      throw new Error(\"Invalid Combination of fontweight and fontstyle\");\n    }\n    if (fontWeight) {\n      fontStyle =\n        fontWeight == 400 || fontWeight === \"normal\"\n          ? fontStyle === \"italic\"\n            ? \"italic\"\n            : \"normal\"\n          : (fontWeight == 700 || fontWeight === \"bold\") &&\n            fontStyle === \"normal\"\n          ? \"bold\"\n          : (fontWeight == 700 ? \"bold\" : fontWeight) + \"\" + fontStyle;\n    }\n    return fontStyle;\n  });\n\n  /**\n   * @callback ApiSwitchBody\n   * @param {jsPDF} pdf\n   */\n\n  /**\n   * For compatibility reasons jsPDF offers two API modes which differ in the way they convert between the the usual\n   * screen coordinates and the PDF coordinate system.\n   *   - \"compat\": Offers full compatibility across all plugins but does not allow arbitrary transforms\n   *   - \"advanced\": Allows arbitrary transforms and more advanced features like pattern fills. Some plugins might\n   *     not support this mode, though.\n   * Initial mode is \"compat\".\n   *\n   * You can either provide a callback to the body argument, which means that jsPDF will automatically switch back to\n   * the original API mode afterwards; or you can omit the callback and switch back manually using {@link compatAPI}.\n   *\n   * Note, that the calls to {@link saveGraphicsState} and {@link restoreGraphicsState} need to be balanced within the\n   * callback or between calls of this method and its counterpart {@link compatAPI}. Calls to {@link beginFormObject}\n   * or {@link beginTilingPattern} need to be closed by their counterparts before switching back to \"compat\" API mode.\n   *\n   * @param {ApiSwitchBody=} body When provided, this callback will be called after the API mode has been switched.\n   * The API mode will be switched back automatically afterwards.\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @name advancedAPI\n   */\n  API.advancedAPI = function(body) {\n    var doSwitch = apiMode === ApiMode.COMPAT;\n\n    if (doSwitch) {\n      advancedAPI.call(this);\n    }\n\n    if (typeof body !== \"function\") {\n      return this;\n    }\n\n    body(this);\n\n    if (doSwitch) {\n      compatAPI.call(this);\n    }\n\n    return this;\n  };\n\n  /**\n   * Switches to \"compat\" API mode. See {@link advancedAPI} for more details.\n   *\n   * @param {ApiSwitchBody=} body When provided, this callback will be called after the API mode has been switched.\n   * The API mode will be switched back automatically afterwards.\n   * @return {jsPDF}\n   * @memberof jsPDF#\n   * @name compatApi\n   */\n  API.compatAPI = function(body) {\n    var doSwitch = apiMode === ApiMode.ADVANCED;\n\n    if (doSwitch) {\n      compatAPI.call(this);\n    }\n\n    if (typeof body !== \"function\") {\n      return this;\n    }\n\n    body(this);\n\n    if (doSwitch) {\n      advancedAPI.call(this);\n    }\n\n    return this;\n  };\n\n  /**\n   * @return {boolean} True iff the current API mode is \"advanced\". See {@link advancedAPI}.\n   * @memberof jsPDF#\n   * @name isAdvancedAPI\n   */\n  API.isAdvancedAPI = function() {\n    return apiMode === ApiMode.ADVANCED;\n  };\n\n  var advancedApiModeTrap = function(methodName) {\n    if (apiMode !== ApiMode.ADVANCED) {\n      throw new Error(\n        methodName +\n          \" is only available in 'advanced' API mode. \" +\n          \"You need to call advancedAPI() first.\"\n      );\n    }\n  };\n\n  var roundToPrecision = (API.roundToPrecision = API.__private__.roundToPrecision = function(\n    number,\n    parmPrecision\n  ) {\n    var tmpPrecision = precision || parmPrecision;\n    if (isNaN(number) || isNaN(tmpPrecision)) {\n      throw new Error(\"Invalid argument passed to jsPDF.roundToPrecision\");\n    }\n    return number.toFixed(tmpPrecision).replace(/0+$/, \"\");\n  });\n\n  // high precision float\n  var hpf;\n  if (typeof floatPrecision === \"number\") {\n    hpf = API.hpf = API.__private__.hpf = function(number) {\n      if (isNaN(number)) {\n        throw new Error(\"Invalid argument passed to jsPDF.hpf\");\n      }\n      return roundToPrecision(number, floatPrecision);\n    };\n  } else if (floatPrecision === \"smart\") {\n    hpf = API.hpf = API.__private__.hpf = function(number) {\n      if (isNaN(number)) {\n        throw new Error(\"Invalid argument passed to jsPDF.hpf\");\n      }\n      if (number > -1 && number < 1) {\n        return roundToPrecision(number, 16);\n      } else {\n        return roundToPrecision(number, 5);\n      }\n    };\n  } else {\n    hpf = API.hpf = API.__private__.hpf = function(number) {\n      if (isNaN(number)) {\n        throw new Error(\"Invalid argument passed to jsPDF.hpf\");\n      }\n      return roundToPrecision(number, 16);\n    };\n  }\n  var f2 = (API.f2 = API.__private__.f2 = function(number) {\n    if (isNaN(number)) {\n      throw new Error(\"Invalid argument passed to jsPDF.f2\");\n    }\n    return roundToPrecision(number, 2);\n  });\n\n  var f3 = (API.__private__.f3 = function(number) {\n    if (isNaN(number)) {\n      throw new Error(\"Invalid argument passed to jsPDF.f3\");\n    }\n    return roundToPrecision(number, 3);\n  });\n\n  var scale = (API.scale = API.__private__.scale = function(number) {\n    if (isNaN(number)) {\n      throw new Error(\"Invalid argument passed to jsPDF.scale\");\n    }\n    if (apiMode === ApiMode.COMPAT) {\n      return number * scaleFactor;\n    } else if (apiMode === ApiMode.ADVANCED) {\n      return number;\n    }\n  });\n\n  var transformY = function(y) {\n    if (apiMode === ApiMode.COMPAT) {\n      return getPageHeight() - y;\n    } else if (apiMode === ApiMode.ADVANCED) {\n      return y;\n    }\n  };\n\n  var transformScaleY = function(y) {\n    return scale(transformY(y));\n  };\n\n  /**\n   * @name setPrecision\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   * @param {string} precision\n   * @returns {jsPDF}\n   */\n  API.__private__.setPrecision = API.setPrecision = function(value) {\n    if (typeof parseInt(value, 10) === \"number\") {\n      precision = parseInt(value, 10);\n    }\n  };\n\n  var fileId = \"00000000000000000000000000000000\";\n\n  var getFileId = (API.__private__.getFileId = function() {\n    return fileId;\n  });\n\n  var setFileId = (API.__private__.setFileId = function(value) {\n    if (typeof value !== \"undefined\" && /^[a-fA-F0-9]{32}$/.test(value)) {\n      fileId = value.toUpperCase();\n    } else {\n      fileId = fileId\n        .split(\"\")\n        .map(function() {\n          return \"ABCDEF0123456789\".charAt(Math.floor(Math.random() * 16));\n        })\n        .join(\"\");\n    }\n\n    if (encryptionOptions !== null) {\n      encryption = new PDFSecurity(\n        encryptionOptions.userPermissions,\n        encryptionOptions.userPassword,\n        encryptionOptions.ownerPassword,\n        fileId\n      );\n    }\n    return fileId;\n  });\n\n  /**\n   * @name setFileId\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   * @param {string} value GUID.\n   * @returns {jsPDF}\n   */\n  API.setFileId = function(value) {\n    setFileId(value);\n    return this;\n  };\n\n  /**\n   * @name getFileId\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   *\n   * @returns {string} GUID.\n   */\n  API.getFileId = function() {\n    return getFileId();\n  };\n\n  var creationDate;\n\n  var convertDateToPDFDate = (API.__private__.convertDateToPDFDate = function(\n    parmDate\n  ) {\n    var result = \"\";\n    var tzoffset = parmDate.getTimezoneOffset(),\n      tzsign = tzoffset < 0 ? \"+\" : \"-\",\n      tzhour = Math.floor(Math.abs(tzoffset / 60)),\n      tzmin = Math.abs(tzoffset % 60),\n      timeZoneString = [tzsign, padd2(tzhour), \"'\", padd2(tzmin), \"'\"].join(\"\");\n\n    result = [\n      \"D:\",\n      parmDate.getFullYear(),\n      padd2(parmDate.getMonth() + 1),\n      padd2(parmDate.getDate()),\n      padd2(parmDate.getHours()),\n      padd2(parmDate.getMinutes()),\n      padd2(parmDate.getSeconds()),\n      timeZoneString\n    ].join(\"\");\n    return result;\n  });\n\n  var convertPDFDateToDate = (API.__private__.convertPDFDateToDate = function(\n    parmPDFDate\n  ) {\n    var year = parseInt(parmPDFDate.substr(2, 4), 10);\n    var month = parseInt(parmPDFDate.substr(6, 2), 10) - 1;\n    var date = parseInt(parmPDFDate.substr(8, 2), 10);\n    var hour = parseInt(parmPDFDate.substr(10, 2), 10);\n    var minutes = parseInt(parmPDFDate.substr(12, 2), 10);\n    var seconds = parseInt(parmPDFDate.substr(14, 2), 10);\n    // var timeZoneHour = parseInt(parmPDFDate.substr(16, 2), 10);\n    // var timeZoneMinutes = parseInt(parmPDFDate.substr(20, 2), 10);\n\n    var resultingDate = new Date(year, month, date, hour, minutes, seconds, 0);\n    return resultingDate;\n  });\n\n  var setCreationDate = (API.__private__.setCreationDate = function(date) {\n    var tmpCreationDateString;\n    var regexPDFCreationDate = /^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\\+0[0-9]|\\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/;\n    if (typeof date === \"undefined\") {\n      date = new Date();\n    }\n\n    if (date instanceof Date) {\n      tmpCreationDateString = convertDateToPDFDate(date);\n    } else if (regexPDFCreationDate.test(date)) {\n      tmpCreationDateString = date;\n    } else {\n      throw new Error(\"Invalid argument passed to jsPDF.setCreationDate\");\n    }\n    creationDate = tmpCreationDateString;\n    return creationDate;\n  });\n\n  var getCreationDate = (API.__private__.getCreationDate = function(type) {\n    var result = creationDate;\n    if (type === \"jsDate\") {\n      result = convertPDFDateToDate(creationDate);\n    }\n    return result;\n  });\n\n  /**\n   * @name setCreationDate\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   * @param {Object} date\n   * @returns {jsPDF}\n   */\n  API.setCreationDate = function(date) {\n    setCreationDate(date);\n    return this;\n  };\n\n  /**\n   * @name getCreationDate\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   * @param {Object} type\n   * @returns {Object}\n   */\n  API.getCreationDate = function(type) {\n    return getCreationDate(type);\n  };\n\n  var padd2 = (API.__private__.padd2 = function(number) {\n    return (\"0\" + parseInt(number)).slice(-2);\n  });\n\n  var padd2Hex = (API.__private__.padd2Hex = function(hexString) {\n    hexString = hexString.toString();\n    return (\"00\" + hexString).substr(hexString.length);\n  });\n\n  var objectNumber = 0; // 'n' Current object number\n  var offsets = []; // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.\n  var content = [];\n  var contentLength = 0;\n  var additionalObjects = [];\n\n  var pages = [];\n  var currentPage;\n  var hasCustomDestination = false;\n  var outputDestination = content;\n\n  var resetDocument = function() {\n    //reset fields relevant for objectNumber generation and xref.\n    objectNumber = 0;\n    contentLength = 0;\n    content = [];\n    offsets = [];\n    additionalObjects = [];\n\n    rootDictionaryObjId = newObjectDeferred();\n    resourceDictionaryObjId = newObjectDeferred();\n  };\n\n  API.__private__.setCustomOutputDestination = function(destination) {\n    hasCustomDestination = true;\n    outputDestination = destination;\n  };\n  var setOutputDestination = function(destination) {\n    if (!hasCustomDestination) {\n      outputDestination = destination;\n    }\n  };\n\n  API.__private__.resetCustomOutputDestination = function() {\n    hasCustomDestination = false;\n    outputDestination = content;\n  };\n\n  var out = (API.__private__.out = function(string) {\n    string = string.toString();\n    contentLength += string.length + 1;\n    outputDestination.push(string);\n\n    return outputDestination;\n  });\n\n  var write = (API.__private__.write = function(value) {\n    return out(\n      arguments.length === 1\n        ? value.toString()\n        : Array.prototype.join.call(arguments, \" \")\n    );\n  });\n\n  var getArrayBuffer = (API.__private__.getArrayBuffer = function(data) {\n    var len = data.length,\n      ab = new ArrayBuffer(len),\n      u8 = new Uint8Array(ab);\n\n    while (len--) u8[len] = data.charCodeAt(len);\n    return ab;\n  });\n\n  var standardFonts = [\n    [\"Helvetica\", \"helvetica\", \"normal\", \"WinAnsiEncoding\"],\n    [\"Helvetica-Bold\", \"helvetica\", \"bold\", \"WinAnsiEncoding\"],\n    [\"Helvetica-Oblique\", \"helvetica\", \"italic\", \"WinAnsiEncoding\"],\n    [\"Helvetica-BoldOblique\", \"helvetica\", \"bolditalic\", \"WinAnsiEncoding\"],\n    [\"Courier\", \"courier\", \"normal\", \"WinAnsiEncoding\"],\n    [\"Courier-Bold\", \"courier\", \"bold\", \"WinAnsiEncoding\"],\n    [\"Courier-Oblique\", \"courier\", \"italic\", \"WinAnsiEncoding\"],\n    [\"Courier-BoldOblique\", \"courier\", \"bolditalic\", \"WinAnsiEncoding\"],\n    [\"Times-Roman\", \"times\", \"normal\", \"WinAnsiEncoding\"],\n    [\"Times-Bold\", \"times\", \"bold\", \"WinAnsiEncoding\"],\n    [\"Times-Italic\", \"times\", \"italic\", \"WinAnsiEncoding\"],\n    [\"Times-BoldItalic\", \"times\", \"bolditalic\", \"WinAnsiEncoding\"],\n    [\"ZapfDingbats\", \"zapfdingbats\", \"normal\", null],\n    [\"Symbol\", \"symbol\", \"normal\", null]\n  ];\n\n  API.__private__.getStandardFonts = function() {\n    return standardFonts;\n  };\n\n  var activeFontSize = options.fontSize || 16;\n\n  /**\n   * Sets font size for upcoming text elements.\n   *\n   * @param {number} size Font size in points.\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @name setFontSize\n   */\n  API.__private__.setFontSize = API.setFontSize = function(size) {\n    if (apiMode === ApiMode.ADVANCED) {\n      activeFontSize = size / scaleFactor;\n    } else {\n      activeFontSize = size;\n    }\n    return this;\n  };\n\n  /**\n   * Gets the fontsize for upcoming text elements.\n   *\n   * @function\n   * @instance\n   * @returns {number}\n   * @memberof jsPDF#\n   * @name getFontSize\n   */\n  var getFontSize = (API.__private__.getFontSize = API.getFontSize = function() {\n    if (apiMode === ApiMode.COMPAT) {\n      return activeFontSize;\n    } else {\n      return activeFontSize * scaleFactor;\n    }\n  });\n\n  var R2L = options.R2L || false;\n\n  /**\n   * Set value of R2L functionality.\n   *\n   * @param {boolean} value\n   * @function\n   * @instance\n   * @returns {jsPDF} jsPDF-instance\n   * @memberof jsPDF#\n   * @name setR2L\n   */\n  API.__private__.setR2L = API.setR2L = function(value) {\n    R2L = value;\n    return this;\n  };\n\n  /**\n   * Get value of R2L functionality.\n   *\n   * @function\n   * @instance\n   * @returns {boolean} jsPDF-instance\n   * @memberof jsPDF#\n   * @name getR2L\n   */\n  API.__private__.getR2L = API.getR2L = function() {\n    return R2L;\n  };\n\n  var zoomMode; // default: 1;\n\n  var setZoomMode = (API.__private__.setZoomMode = function(zoom) {\n    var validZoomModes = [\n      undefined,\n      null,\n      \"fullwidth\",\n      \"fullheight\",\n      \"fullpage\",\n      \"original\"\n    ];\n\n    if (/^\\d*\\.?\\d*%$/.test(zoom)) {\n      zoomMode = zoom;\n    } else if (!isNaN(zoom)) {\n      zoomMode = parseInt(zoom, 10);\n    } else if (validZoomModes.indexOf(zoom) !== -1) {\n      zoomMode = zoom;\n    } else {\n      throw new Error(\n        'zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. \"' +\n          zoom +\n          '\" is not recognized.'\n      );\n    }\n  });\n\n  API.__private__.getZoomMode = function() {\n    return zoomMode;\n  };\n\n  var pageMode; // default: 'UseOutlines';\n  var setPageMode = (API.__private__.setPageMode = function(pmode) {\n    var validPageModes = [\n      undefined,\n      null,\n      \"UseNone\",\n      \"UseOutlines\",\n      \"UseThumbs\",\n      \"FullScreen\"\n    ];\n\n    if (validPageModes.indexOf(pmode) == -1) {\n      throw new Error(\n        'Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. \"' +\n          pmode +\n          '\" is not recognized.'\n      );\n    }\n    pageMode = pmode;\n  });\n\n  API.__private__.getPageMode = function() {\n    return pageMode;\n  };\n\n  var layoutMode; // default: 'continuous';\n  var setLayoutMode = (API.__private__.setLayoutMode = function(layout) {\n    var validLayoutModes = [\n      undefined,\n      null,\n      \"continuous\",\n      \"single\",\n      \"twoleft\",\n      \"tworight\",\n      \"two\"\n    ];\n\n    if (validLayoutModes.indexOf(layout) == -1) {\n      throw new Error(\n        'Layout mode must be one of continuous, single, twoleft, tworight. \"' +\n          layout +\n          '\" is not recognized.'\n      );\n    }\n    layoutMode = layout;\n  });\n\n  API.__private__.getLayoutMode = function() {\n    return layoutMode;\n  };\n\n  /**\n   * Set the display mode options of the page like zoom and layout.\n   *\n   * @name setDisplayMode\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   * @param {integer|String} zoom   You can pass an integer or percentage as\n   * a string. 2 will scale the document up 2x, '200%' will scale up by the\n   * same amount. You can also set it to 'fullwidth', 'fullheight',\n   * 'fullpage', or 'original'.\n   *\n   * Only certain PDF readers support this, such as Adobe Acrobat.\n   *\n   * @param {string} layout Layout mode can be: 'continuous' - this is the\n   * default continuous scroll. 'single' - the single page mode only shows one\n   * page at a time. 'twoleft' - two column left mode, first page starts on\n   * the left, and 'tworight' - pages are laid out in two columns, with the\n   * first page on the right. This would be used for books.\n   * @param {string} pmode 'UseOutlines' - it shows the\n   * outline of the document on the left. 'UseThumbs' - shows thumbnails along\n   * the left. 'FullScreen' - prompts the user to enter fullscreen mode.\n   *\n   * @returns {jsPDF}\n   */\n  API.__private__.setDisplayMode = API.setDisplayMode = function(\n    zoom,\n    layout,\n    pmode\n  ) {\n    setZoomMode(zoom);\n    setLayoutMode(layout);\n    setPageMode(pmode);\n    return this;\n  };\n\n  var documentProperties = {\n    title: \"\",\n    subject: \"\",\n    author: \"\",\n    keywords: \"\",\n    creator: \"\"\n  };\n\n  API.__private__.getDocumentProperty = function(key) {\n    if (Object.keys(documentProperties).indexOf(key) === -1) {\n      throw new Error(\"Invalid argument passed to jsPDF.getDocumentProperty\");\n    }\n    return documentProperties[key];\n  };\n\n  API.__private__.getDocumentProperties = function() {\n    return documentProperties;\n  };\n\n  /**\n   * Adds a properties to the PDF document.\n   *\n   * @param {Object} A property_name-to-property_value object structure.\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @name setDocumentProperties\n   */\n  API.__private__.setDocumentProperties = API.setProperties = API.setDocumentProperties = function(\n    properties\n  ) {\n    // copying only those properties we can render.\n    for (var property in documentProperties) {\n      if (documentProperties.hasOwnProperty(property) && properties[property]) {\n        documentProperties[property] = properties[property];\n      }\n    }\n    return this;\n  };\n\n  API.__private__.setDocumentProperty = function(key, value) {\n    if (Object.keys(documentProperties).indexOf(key) === -1) {\n      throw new Error(\"Invalid arguments passed to jsPDF.setDocumentProperty\");\n    }\n    return (documentProperties[key] = value);\n  };\n\n  var fonts = {}; // collection of font objects, where key is fontKey - a dynamically created label for a given font.\n  var fontmap = {}; // mapping structure fontName > fontStyle > font key - performance layer. See addFont()\n  var activeFontKey; // will be string representing the KEY of the font as combination of fontName + fontStyle\n  var fontStateStack = []; //\n  var patterns = {}; // collection of pattern objects\n  var patternMap = {}; // see fonts\n  var gStates = {}; // collection of graphic state objects\n  var gStatesMap = {}; // see fonts\n  var activeGState = null;\n  var scaleFactor; // Scale factor\n  var page = 0;\n  var pagesContext = [];\n  var events = new PubSub(API);\n  var hotfixes = options.hotfixes || [];\n\n  var renderTargets = {};\n  var renderTargetMap = {};\n  var renderTargetStack = [];\n  var pageX;\n  var pageY;\n  var pageMatrix; // only used for FormObjects\n\n  /**\n   * A matrix object for 2D homogenous transformations: <br>\n   * | a b 0 | <br>\n   * | c d 0 | <br>\n   * | e f 1 | <br>\n   * pdf multiplies matrices righthand: v' = v x m1 x m2 x ...\n   *\n   * @class\n   * @name Matrix\n   * @param {number} sx\n   * @param {number} shy\n   * @param {number} shx\n   * @param {number} sy\n   * @param {number} tx\n   * @param {number} ty\n   * @constructor\n   */\n  var Matrix = function(sx, shy, shx, sy, tx, ty) {\n    if (!(this instanceof Matrix)) {\n      return new Matrix(sx, shy, shx, sy, tx, ty);\n    }\n\n    if (isNaN(sx)) sx = 1;\n    if (isNaN(shy)) shy = 0;\n    if (isNaN(shx)) shx = 0;\n    if (isNaN(sy)) sy = 1;\n    if (isNaN(tx)) tx = 0;\n    if (isNaN(ty)) ty = 0;\n\n    this._matrix = [sx, shy, shx, sy, tx, ty];\n  };\n\n  /**\n   * @name sx\n   * @memberof Matrix#\n   */\n  Object.defineProperty(Matrix.prototype, \"sx\", {\n    get: function() {\n      return this._matrix[0];\n    },\n    set: function(value) {\n      this._matrix[0] = value;\n    }\n  });\n\n  /**\n   * @name shy\n   * @memberof Matrix#\n   */\n  Object.defineProperty(Matrix.prototype, \"shy\", {\n    get: function() {\n      return this._matrix[1];\n    },\n    set: function(value) {\n      this._matrix[1] = value;\n    }\n  });\n\n  /**\n   * @name shx\n   * @memberof Matrix#\n   */\n  Object.defineProperty(Matrix.prototype, \"shx\", {\n    get: function() {\n      return this._matrix[2];\n    },\n    set: function(value) {\n      this._matrix[2] = value;\n    }\n  });\n\n  /**\n   * @name sy\n   * @memberof Matrix#\n   */\n  Object.defineProperty(Matrix.prototype, \"sy\", {\n    get: function() {\n      return this._matrix[3];\n    },\n    set: function(value) {\n      this._matrix[3] = value;\n    }\n  });\n\n  /**\n   * @name tx\n   * @memberof Matrix#\n   */\n  Object.defineProperty(Matrix.prototype, \"tx\", {\n    get: function() {\n      return this._matrix[4];\n    },\n    set: function(value) {\n      this._matrix[4] = value;\n    }\n  });\n\n  /**\n   * @name ty\n   * @memberof Matrix#\n   */\n  Object.defineProperty(Matrix.prototype, \"ty\", {\n    get: function() {\n      return this._matrix[5];\n    },\n    set: function(value) {\n      this._matrix[5] = value;\n    }\n  });\n\n  Object.defineProperty(Matrix.prototype, \"a\", {\n    get: function() {\n      return this._matrix[0];\n    },\n    set: function(value) {\n      this._matrix[0] = value;\n    }\n  });\n\n  Object.defineProperty(Matrix.prototype, \"b\", {\n    get: function() {\n      return this._matrix[1];\n    },\n    set: function(value) {\n      this._matrix[1] = value;\n    }\n  });\n\n  Object.defineProperty(Matrix.prototype, \"c\", {\n    get: function() {\n      return this._matrix[2];\n    },\n    set: function(value) {\n      this._matrix[2] = value;\n    }\n  });\n\n  Object.defineProperty(Matrix.prototype, \"d\", {\n    get: function() {\n      return this._matrix[3];\n    },\n    set: function(value) {\n      this._matrix[3] = value;\n    }\n  });\n\n  Object.defineProperty(Matrix.prototype, \"e\", {\n    get: function() {\n      return this._matrix[4];\n    },\n    set: function(value) {\n      this._matrix[4] = value;\n    }\n  });\n\n  Object.defineProperty(Matrix.prototype, \"f\", {\n    get: function() {\n      return this._matrix[5];\n    },\n    set: function(value) {\n      this._matrix[5] = value;\n    }\n  });\n\n  /**\n   * @name rotation\n   * @memberof Matrix#\n   */\n  Object.defineProperty(Matrix.prototype, \"rotation\", {\n    get: function() {\n      return Math.atan2(this.shx, this.sx);\n    }\n  });\n\n  /**\n   * @name scaleX\n   * @memberof Matrix#\n   */\n  Object.defineProperty(Matrix.prototype, \"scaleX\", {\n    get: function() {\n      return this.decompose().scale.sx;\n    }\n  });\n\n  /**\n   * @name scaleY\n   * @memberof Matrix#\n   */\n  Object.defineProperty(Matrix.prototype, \"scaleY\", {\n    get: function() {\n      return this.decompose().scale.sy;\n    }\n  });\n\n  /**\n   * @name isIdentity\n   * @memberof Matrix#\n   */\n  Object.defineProperty(Matrix.prototype, \"isIdentity\", {\n    get: function() {\n      if (this.sx !== 1) {\n        return false;\n      }\n      if (this.shy !== 0) {\n        return false;\n      }\n      if (this.shx !== 0) {\n        return false;\n      }\n      if (this.sy !== 1) {\n        return false;\n      }\n      if (this.tx !== 0) {\n        return false;\n      }\n      if (this.ty !== 0) {\n        return false;\n      }\n      return true;\n    }\n  });\n\n  /**\n   * Join the Matrix Values to a String\n   *\n   * @function join\n   * @param {string} separator Specifies a string to separate each pair of adjacent elements of the array. The separator is converted to a string if necessary. If omitted, the array elements are separated with a comma (\",\"). If separator is an empty string, all elements are joined without any characters in between them.\n   * @returns {string} A string with all array elements joined.\n   * @memberof Matrix#\n   */\n  Matrix.prototype.join = function(separator) {\n    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty]\n      .map(hpf)\n      .join(separator);\n  };\n\n  /**\n   * Multiply the matrix with given Matrix\n   *\n   * @function multiply\n   * @param matrix\n   * @returns {Matrix}\n   * @memberof Matrix#\n   */\n  Matrix.prototype.multiply = function(matrix) {\n    var sx = matrix.sx * this.sx + matrix.shy * this.shx;\n    var shy = matrix.sx * this.shy + matrix.shy * this.sy;\n    var shx = matrix.shx * this.sx + matrix.sy * this.shx;\n    var sy = matrix.shx * this.shy + matrix.sy * this.sy;\n    var tx = matrix.tx * this.sx + matrix.ty * this.shx + this.tx;\n    var ty = matrix.tx * this.shy + matrix.ty * this.sy + this.ty;\n\n    return new Matrix(sx, shy, shx, sy, tx, ty);\n  };\n\n  /**\n   * @function decompose\n   * @memberof Matrix#\n   */\n  Matrix.prototype.decompose = function() {\n    var a = this.sx;\n    var b = this.shy;\n    var c = this.shx;\n    var d = this.sy;\n    var e = this.tx;\n    var f = this.ty;\n\n    var scaleX = Math.sqrt(a * a + b * b);\n    a /= scaleX;\n    b /= scaleX;\n\n    var shear = a * c + b * d;\n    c -= a * shear;\n    d -= b * shear;\n\n    var scaleY = Math.sqrt(c * c + d * d);\n    c /= scaleY;\n    d /= scaleY;\n    shear /= scaleY;\n\n    if (a * d < b * c) {\n      a = -a;\n      b = -b;\n      shear = -shear;\n      scaleX = -scaleX;\n    }\n\n    return {\n      scale: new Matrix(scaleX, 0, 0, scaleY, 0, 0),\n      translate: new Matrix(1, 0, 0, 1, e, f),\n      rotate: new Matrix(a, b, -b, a, 0, 0),\n      skew: new Matrix(1, 0, shear, 1, 0, 0)\n    };\n  };\n\n  /**\n   * @function toString\n   * @memberof Matrix#\n   */\n  Matrix.prototype.toString = function(parmPrecision) {\n    return this.join(\" \");\n  };\n\n  /**\n   * @function inversed\n   * @memberof Matrix#\n   */\n  Matrix.prototype.inversed = function() {\n    var a = this.sx,\n      b = this.shy,\n      c = this.shx,\n      d = this.sy,\n      e = this.tx,\n      f = this.ty;\n\n    var quot = 1 / (a * d - b * c);\n\n    var aInv = d * quot;\n    var bInv = -b * quot;\n    var cInv = -c * quot;\n    var dInv = a * quot;\n    var eInv = -aInv * e - cInv * f;\n    var fInv = -bInv * e - dInv * f;\n\n    return new Matrix(aInv, bInv, cInv, dInv, eInv, fInv);\n  };\n\n  /**\n   * @function applyToPoint\n   * @memberof Matrix#\n   */\n  Matrix.prototype.applyToPoint = function(pt) {\n    var x = pt.x * this.sx + pt.y * this.shx + this.tx;\n    var y = pt.x * this.shy + pt.y * this.sy + this.ty;\n    return new Point(x, y);\n  };\n\n  /**\n   * @function applyToRectangle\n   * @memberof Matrix#\n   */\n  Matrix.prototype.applyToRectangle = function(rect) {\n    var pt1 = this.applyToPoint(rect);\n    var pt2 = this.applyToPoint(new Point(rect.x + rect.w, rect.y + rect.h));\n    return new Rectangle(pt1.x, pt1.y, pt2.x - pt1.x, pt2.y - pt1.y);\n  };\n\n  /**\n   * Clone the Matrix\n   *\n   * @function clone\n   * @memberof Matrix#\n   * @name clone\n   * @instance\n   */\n  Matrix.prototype.clone = function() {\n    var sx = this.sx;\n    var shy = this.shy;\n    var shx = this.shx;\n    var sy = this.sy;\n    var tx = this.tx;\n    var ty = this.ty;\n\n    return new Matrix(sx, shy, shx, sy, tx, ty);\n  };\n\n  API.Matrix = Matrix;\n\n  /**\n   * Multiplies two matrices. (see {@link Matrix})\n   * @param {Matrix} m1\n   * @param {Matrix} m2\n   * @memberof jsPDF#\n   * @name matrixMult\n   */\n  var matrixMult = (API.matrixMult = function(m1, m2) {\n    return m2.multiply(m1);\n  });\n\n  /**\n   * The identity matrix (equivalent to new Matrix(1, 0, 0, 1, 0, 0)).\n   * @type {Matrix}\n   * @memberof! jsPDF#\n   * @name identityMatrix\n   */\n  var identityMatrix = new Matrix(1, 0, 0, 1, 0, 0);\n  API.unitMatrix = API.identityMatrix = identityMatrix;\n\n  /**\n   * Adds a new pattern for later use.\n   * @param {String} key The key by it can be referenced later. The keys must be unique!\n   * @param {API.Pattern} pattern The pattern\n   */\n  var addPattern = function(key, pattern) {\n    // only add it if it is not already present (the keys provided by the user must be unique!)\n    if (patternMap[key]) return;\n\n    var prefix = pattern instanceof ShadingPattern ? \"Sh\" : \"P\";\n    var patternKey = prefix + (Object.keys(patterns).length + 1).toString(10);\n    pattern.id = patternKey;\n\n    patternMap[key] = patternKey;\n    patterns[patternKey] = pattern;\n\n    events.publish(\"addPattern\", pattern);\n  };\n\n  /**\n   * A pattern describing a shading pattern.\n   *\n   * Only available in \"advanced\" API mode.\n   *\n   * @param {String} type One of \"axial\" or \"radial\"\n   * @param {Array<Number>} coords Either [x1, y1, x2, y2] for \"axial\" type describing the two interpolation points\n   * or [x1, y1, r, x2, y2, r2] for \"radial\" describing inner and the outer circle.\n   * @param {Array<Object>} colors An array of objects with the fields \"offset\" and \"color\". \"offset\" describes\n   * the offset in parameter space [0, 1]. \"color\" is an array of length 3 describing RGB values in [0, 255].\n   * @param {GState=} gState An additional graphics state that gets applied to the pattern (optional).\n   * @param {Matrix=} matrix A matrix that describes the transformation between the pattern coordinate system\n   * and the use coordinate system (optional).\n   * @constructor\n   * @extends API.Pattern\n   */\n  API.ShadingPattern = ShadingPattern;\n\n  /**\n   * A PDF Tiling pattern.\n   *\n   * Only available in \"advanced\" API mode.\n   *\n   * @param {Array.<Number>} boundingBox The bounding box at which one pattern cell gets clipped.\n   * @param {Number} xStep Horizontal spacing between pattern cells.\n   * @param {Number} yStep Vertical spacing between pattern cells.\n   * @param {API.GState=} gState An additional graphics state that gets applied to the pattern (optional).\n   * @param {Matrix=} matrix A matrix that describes the transformation between the pattern coordinate system\n   * and the use coordinate system (optional).\n   * @constructor\n   * @extends API.Pattern\n   */\n  API.TilingPattern = TilingPattern;\n\n  /**\n   * Adds a new {@link API.ShadingPattern} for later use. Only available in \"advanced\" API mode.\n   * @param {String} key\n   * @param {Pattern} pattern\n   * @function\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @name addPattern\n   */\n  API.addShadingPattern = function(key, pattern) {\n    advancedApiModeTrap(\"addShadingPattern()\");\n\n    addPattern(key, pattern);\n    return this;\n  };\n\n  /**\n   * Begins a new tiling pattern. All subsequent render calls are drawn to this pattern until {@link API.endTilingPattern}\n   * gets called. Only available in \"advanced\" API mode.\n   * @param {API.Pattern} pattern\n   * @memberof jsPDF#\n   * @name beginTilingPattern\n   */\n  API.beginTilingPattern = function(pattern) {\n    advancedApiModeTrap(\"beginTilingPattern()\");\n\n    beginNewRenderTarget(\n      pattern.boundingBox[0],\n      pattern.boundingBox[1],\n      pattern.boundingBox[2] - pattern.boundingBox[0],\n      pattern.boundingBox[3] - pattern.boundingBox[1],\n      pattern.matrix\n    );\n  };\n\n  /**\n   * Ends a tiling pattern and sets the render target to the one active before {@link API.beginTilingPattern} has been called.\n   *\n   * Only available in \"advanced\" API mode.\n   *\n   * @param {string} key A unique key that is used to reference this pattern at later use.\n   * @param {API.Pattern} pattern The pattern to end.\n   * @memberof jsPDF#\n   * @name endTilingPattern\n   */\n  API.endTilingPattern = function(key, pattern) {\n    advancedApiModeTrap(\"endTilingPattern()\");\n\n    // retrieve the stream\n    pattern.stream = pages[currentPage].join(\"\\n\");\n\n    addPattern(key, pattern);\n\n    events.publish(\"endTilingPattern\", pattern);\n\n    // restore state from stack\n    renderTargetStack.pop().restore();\n  };\n\n  var newObject = (API.__private__.newObject = function() {\n    var oid = newObjectDeferred();\n    newObjectDeferredBegin(oid, true);\n    return oid;\n  });\n\n  // Does not output the object.  The caller must call newObjectDeferredBegin(oid) before outputing any data\n  var newObjectDeferred = (API.__private__.newObjectDeferred = function() {\n    objectNumber++;\n    offsets[objectNumber] = function() {\n      return contentLength;\n    };\n    return objectNumber;\n  });\n\n  var newObjectDeferredBegin = function(oid, doOutput) {\n    doOutput = typeof doOutput === \"boolean\" ? doOutput : false;\n    offsets[oid] = contentLength;\n    if (doOutput) {\n      out(oid + \" 0 obj\");\n    }\n    return oid;\n  };\n  // Does not output the object until after the pages have been output.\n  // Returns an object containing the objectId and content.\n  // All pages have been added so the object ID can be estimated to start right after.\n  // This does not modify the current objectNumber;  It must be updated after the newObjects are output.\n  var newAdditionalObject = (API.__private__.newAdditionalObject = function() {\n    var objId = newObjectDeferred();\n    var obj = {\n      objId: objId,\n      content: \"\"\n    };\n    additionalObjects.push(obj);\n    return obj;\n  });\n\n  var rootDictionaryObjId = newObjectDeferred();\n  var resourceDictionaryObjId = newObjectDeferred();\n\n  /////////////////////\n  // Private functions\n  /////////////////////\n\n  var decodeColorString = (API.__private__.decodeColorString = function(color) {\n    var colorEncoded = color.split(\" \");\n    if (\n      colorEncoded.length === 2 &&\n      (colorEncoded[1] === \"g\" || colorEncoded[1] === \"G\")\n    ) {\n      // convert grayscale value to rgb so that it can be converted to hex for consistency\n      var floatVal = parseFloat(colorEncoded[0]);\n      colorEncoded = [floatVal, floatVal, floatVal, \"r\"];\n    } else if (\n      colorEncoded.length === 5 &&\n      (colorEncoded[4] === \"k\" || colorEncoded[4] === \"K\")\n    ) {\n      // convert CMYK values to rbg so that it can be converted to hex for consistency\n      var red = (1.0 - colorEncoded[0]) * (1.0 - colorEncoded[3]);\n      var green = (1.0 - colorEncoded[1]) * (1.0 - colorEncoded[3]);\n      var blue = (1.0 - colorEncoded[2]) * (1.0 - colorEncoded[3]);\n\n      colorEncoded = [red, green, blue, \"r\"];\n    }\n    var colorAsRGB = \"#\";\n    for (var i = 0; i < 3; i++) {\n      colorAsRGB += (\n        \"0\" + Math.floor(parseFloat(colorEncoded[i]) * 255).toString(16)\n      ).slice(-2);\n    }\n    return colorAsRGB;\n  });\n\n  var encodeColorString = (API.__private__.encodeColorString = function(\n    options\n  ) {\n    var color;\n\n    if (typeof options === \"string\") {\n      options = {\n        ch1: options\n      };\n    }\n    var ch1 = options.ch1;\n    var ch2 = options.ch2;\n    var ch3 = options.ch3;\n    var ch4 = options.ch4;\n    var letterArray =\n      options.pdfColorType === \"draw\" ? [\"G\", \"RG\", \"K\"] : [\"g\", \"rg\", \"k\"];\n\n    if (typeof ch1 === \"string\" && ch1.charAt(0) !== \"#\") {\n      var rgbColor = new RGBColor(ch1);\n      if (rgbColor.ok) {\n        ch1 = rgbColor.toHex();\n      } else if (!/^\\d*\\.?\\d*$/.test(ch1)) {\n        throw new Error(\n          'Invalid color \"' + ch1 + '\" passed to jsPDF.encodeColorString.'\n        );\n      }\n    }\n    //convert short rgb to long form\n    if (typeof ch1 === \"string\" && /^#[0-9A-Fa-f]{3}$/.test(ch1)) {\n      ch1 = \"#\" + ch1[1] + ch1[1] + ch1[2] + ch1[2] + ch1[3] + ch1[3];\n    }\n\n    if (typeof ch1 === \"string\" && /^#[0-9A-Fa-f]{6}$/.test(ch1)) {\n      var hex = parseInt(ch1.substr(1), 16);\n      ch1 = (hex >> 16) & 255;\n      ch2 = (hex >> 8) & 255;\n      ch3 = hex & 255;\n    }\n\n    if (\n      typeof ch2 === \"undefined\" ||\n      (typeof ch4 === \"undefined\" && ch1 === ch2 && ch2 === ch3)\n    ) {\n      // Gray color space.\n      if (typeof ch1 === \"string\") {\n        color = ch1 + \" \" + letterArray[0];\n      } else {\n        switch (options.precision) {\n          case 2:\n            color = f2(ch1 / 255) + \" \" + letterArray[0];\n            break;\n          case 3:\n          default:\n            color = f3(ch1 / 255) + \" \" + letterArray[0];\n        }\n      }\n    } else if (typeof ch4 === \"undefined\" || typeof ch4 === \"object\") {\n      // assume RGBA\n      if (ch4 && !isNaN(ch4.a)) {\n        //TODO Implement transparency.\n        //WORKAROUND use white for now, if transparent, otherwise handle as rgb\n        if (ch4.a === 0) {\n          color = [\"1.\", \"1.\", \"1.\", letterArray[1]].join(\" \");\n          return color;\n        }\n      }\n      // assume RGB\n      if (typeof ch1 === \"string\") {\n        color = [ch1, ch2, ch3, letterArray[1]].join(\" \");\n      } else {\n        switch (options.precision) {\n          case 2:\n            color = [\n              f2(ch1 / 255),\n              f2(ch2 / 255),\n              f2(ch3 / 255),\n              letterArray[1]\n            ].join(\" \");\n            break;\n          default:\n          case 3:\n            color = [\n              f3(ch1 / 255),\n              f3(ch2 / 255),\n              f3(ch3 / 255),\n              letterArray[1]\n            ].join(\" \");\n        }\n      }\n    } else {\n      // assume CMYK\n      if (typeof ch1 === \"string\") {\n        color = [ch1, ch2, ch3, ch4, letterArray[2]].join(\" \");\n      } else {\n        switch (options.precision) {\n          case 2:\n            color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), letterArray[2]].join(\n              \" \"\n            );\n            break;\n          case 3:\n          default:\n            color = [f3(ch1), f3(ch2), f3(ch3), f3(ch4), letterArray[2]].join(\n              \" \"\n            );\n        }\n      }\n    }\n    return color;\n  });\n\n  var getFilters = (API.__private__.getFilters = function() {\n    return filters;\n  });\n\n  var putStream = (API.__private__.putStream = function(options) {\n    options = options || {};\n    var data = options.data || \"\";\n    var filters = options.filters || getFilters();\n    var alreadyAppliedFilters = options.alreadyAppliedFilters || [];\n    var addLength1 = options.addLength1 || false;\n    var valueOfLength1 = data.length;\n    var objectId = options.objectId;\n    var encryptor = function(data) {\n      return data;\n    };\n    if (encryptionOptions !== null && typeof objectId == \"undefined\") {\n      throw new Error(\n        \"ObjectId must be passed to putStream for file encryption\"\n      );\n    }\n    if (encryptionOptions !== null) {\n      encryptor = encryption.encryptor(objectId, 0);\n    }\n\n    var processedData = {};\n    if (filters === true) {\n      filters = [\"FlateEncode\"];\n    }\n    var keyValues = options.additionalKeyValues || [];\n    if (typeof jsPDF.API.processDataByFilters !== \"undefined\") {\n      processedData = jsPDF.API.processDataByFilters(data, filters);\n    } else {\n      processedData = { data: data, reverseChain: [] };\n    }\n    var filterAsString =\n      processedData.reverseChain +\n      (Array.isArray(alreadyAppliedFilters)\n        ? alreadyAppliedFilters.join(\" \")\n        : alreadyAppliedFilters.toString());\n\n    if (processedData.data.length !== 0) {\n      keyValues.push({\n        key: \"Length\",\n        value: processedData.data.length\n      });\n      if (addLength1 === true) {\n        keyValues.push({\n          key: \"Length1\",\n          value: valueOfLength1\n        });\n      }\n    }\n\n    if (filterAsString.length != 0) {\n      if (filterAsString.split(\"/\").length - 1 === 1) {\n        keyValues.push({\n          key: \"Filter\",\n          value: filterAsString\n        });\n      } else {\n        keyValues.push({\n          key: \"Filter\",\n          value: \"[\" + filterAsString + \"]\"\n        });\n\n        for (var j = 0; j < keyValues.length; j += 1) {\n          if (keyValues[j].key === \"DecodeParms\") {\n            var decodeParmsArray = [];\n\n            for (\n              var i = 0;\n              i < processedData.reverseChain.split(\"/\").length - 1;\n              i += 1\n            ) {\n              decodeParmsArray.push(\"null\");\n            }\n\n            decodeParmsArray.push(keyValues[j].value);\n            keyValues[j].value = \"[\" + decodeParmsArray.join(\" \") + \"]\";\n          }\n        }\n      }\n    }\n\n    out(\"<<\");\n    for (var k = 0; k < keyValues.length; k++) {\n      out(\"/\" + keyValues[k].key + \" \" + keyValues[k].value);\n    }\n    out(\">>\");\n    if (processedData.data.length !== 0) {\n      out(\"stream\");\n      out(encryptor(processedData.data));\n      out(\"endstream\");\n    }\n  });\n\n  var putPage = (API.__private__.putPage = function(page) {\n    var pageNumber = page.number;\n    var data = page.data;\n    var pageObjectNumber = page.objId;\n    var pageContentsObjId = page.contentsObjId;\n\n    newObjectDeferredBegin(pageObjectNumber, true);\n    out(\"<</Type /Page\");\n    out(\"/Parent \" + page.rootDictionaryObjId + \" 0 R\");\n    out(\"/Resources \" + page.resourceDictionaryObjId + \" 0 R\");\n    out(\n      \"/MediaBox [\" +\n        parseFloat(hpf(page.mediaBox.bottomLeftX)) +\n        \" \" +\n        parseFloat(hpf(page.mediaBox.bottomLeftY)) +\n        \" \" +\n        hpf(page.mediaBox.topRightX) +\n        \" \" +\n        hpf(page.mediaBox.topRightY) +\n        \"]\"\n    );\n    if (page.cropBox !== null) {\n      out(\n        \"/CropBox [\" +\n          hpf(page.cropBox.bottomLeftX) +\n          \" \" +\n          hpf(page.cropBox.bottomLeftY) +\n          \" \" +\n          hpf(page.cropBox.topRightX) +\n          \" \" +\n          hpf(page.cropBox.topRightY) +\n          \"]\"\n      );\n    }\n\n    if (page.bleedBox !== null) {\n      out(\n        \"/BleedBox [\" +\n          hpf(page.bleedBox.bottomLeftX) +\n          \" \" +\n          hpf(page.bleedBox.bottomLeftY) +\n          \" \" +\n          hpf(page.bleedBox.topRightX) +\n          \" \" +\n          hpf(page.bleedBox.topRightY) +\n          \"]\"\n      );\n    }\n\n    if (page.trimBox !== null) {\n      out(\n        \"/TrimBox [\" +\n          hpf(page.trimBox.bottomLeftX) +\n          \" \" +\n          hpf(page.trimBox.bottomLeftY) +\n          \" \" +\n          hpf(page.trimBox.topRightX) +\n          \" \" +\n          hpf(page.trimBox.topRightY) +\n          \"]\"\n      );\n    }\n\n    if (page.artBox !== null) {\n      out(\n        \"/ArtBox [\" +\n          hpf(page.artBox.bottomLeftX) +\n          \" \" +\n          hpf(page.artBox.bottomLeftY) +\n          \" \" +\n          hpf(page.artBox.topRightX) +\n          \" \" +\n          hpf(page.artBox.topRightY) +\n          \"]\"\n      );\n    }\n\n    if (typeof page.userUnit === \"number\" && page.userUnit !== 1.0) {\n      out(\"/UserUnit \" + page.userUnit);\n    }\n\n    events.publish(\"putPage\", {\n      objId: pageObjectNumber,\n      pageContext: pagesContext[pageNumber],\n      pageNumber: pageNumber,\n      page: data\n    });\n    out(\"/Contents \" + pageContentsObjId + \" 0 R\");\n    out(\">>\");\n    out(\"endobj\");\n    // Page content\n    var pageContent = data.join(\"\\n\");\n\n    if (apiMode === ApiMode.ADVANCED) {\n      // if the user forgot to switch back to COMPAT mode, we must balance the graphics stack again\n      pageContent += \"\\nQ\";\n    }\n\n    newObjectDeferredBegin(pageContentsObjId, true);\n    putStream({\n      data: pageContent,\n      filters: getFilters(),\n      objectId: pageContentsObjId\n    });\n    out(\"endobj\");\n    return pageObjectNumber;\n  });\n\n  var putPages = (API.__private__.putPages = function() {\n    var n,\n      i,\n      pageObjectNumbers = [];\n\n    for (n = 1; n <= page; n++) {\n      pagesContext[n].objId = newObjectDeferred();\n      pagesContext[n].contentsObjId = newObjectDeferred();\n    }\n\n    for (n = 1; n <= page; n++) {\n      pageObjectNumbers.push(\n        putPage({\n          number: n,\n          data: pages[n],\n          objId: pagesContext[n].objId,\n          contentsObjId: pagesContext[n].contentsObjId,\n          mediaBox: pagesContext[n].mediaBox,\n          cropBox: pagesContext[n].cropBox,\n          bleedBox: pagesContext[n].bleedBox,\n          trimBox: pagesContext[n].trimBox,\n          artBox: pagesContext[n].artBox,\n          userUnit: pagesContext[n].userUnit,\n          rootDictionaryObjId: rootDictionaryObjId,\n          resourceDictionaryObjId: resourceDictionaryObjId\n        })\n      );\n    }\n    newObjectDeferredBegin(rootDictionaryObjId, true);\n    out(\"<</Type /Pages\");\n    var kids = \"/Kids [\";\n    for (i = 0; i < page; i++) {\n      kids += pageObjectNumbers[i] + \" 0 R \";\n    }\n    out(kids + \"]\");\n    out(\"/Count \" + page);\n    out(\">>\");\n    out(\"endobj\");\n    events.publish(\"postPutPages\");\n  });\n\n  var putFont = function(font) {\n    events.publish(\"putFont\", {\n      font: font,\n      out: out,\n      newObject: newObject,\n      putStream: putStream\n    });\n\n    if (font.isAlreadyPutted !== true) {\n      font.objectNumber = newObject();\n      out(\"<<\");\n      out(\"/Type /Font\");\n      out(\"/BaseFont /\" + toPDFName(font.postScriptName));\n      out(\"/Subtype /Type1\");\n      if (typeof font.encoding === \"string\") {\n        out(\"/Encoding /\" + font.encoding);\n      }\n      out(\"/FirstChar 32\");\n      out(\"/LastChar 255\");\n      out(\">>\");\n      out(\"endobj\");\n    }\n  };\n\n  var putFonts = function() {\n    for (var fontKey in fonts) {\n      if (fonts.hasOwnProperty(fontKey)) {\n        if (\n          putOnlyUsedFonts === false ||\n          (putOnlyUsedFonts === true && usedFonts.hasOwnProperty(fontKey))\n        ) {\n          putFont(fonts[fontKey]);\n        }\n      }\n    }\n  };\n\n  var putXObject = function(xObject) {\n    xObject.objectNumber = newObject();\n\n    var options = [];\n    options.push({ key: \"Type\", value: \"/XObject\" });\n    options.push({ key: \"Subtype\", value: \"/Form\" });\n    options.push({\n      key: \"BBox\",\n      value:\n        \"[\" +\n        [\n          hpf(xObject.x),\n          hpf(xObject.y),\n          hpf(xObject.x + xObject.width),\n          hpf(xObject.y + xObject.height)\n        ].join(\" \") +\n        \"]\"\n    });\n    options.push({\n      key: \"Matrix\",\n      value: \"[\" + xObject.matrix.toString() + \"]\"\n    });\n    // TODO: /Resources\n\n    var stream = xObject.pages[1].join(\"\\n\");\n    putStream({\n      data: stream,\n      additionalKeyValues: options,\n      objectId: xObject.objectNumber\n    });\n    out(\"endobj\");\n  };\n\n  var putXObjects = function() {\n    for (var xObjectKey in renderTargets) {\n      if (renderTargets.hasOwnProperty(xObjectKey)) {\n        putXObject(renderTargets[xObjectKey]);\n      }\n    }\n  };\n\n  var interpolateAndEncodeRGBStream = function(colors, numberSamples) {\n    var tValues = [];\n    var t;\n    var dT = 1.0 / (numberSamples - 1);\n    for (t = 0.0; t < 1.0; t += dT) {\n      tValues.push(t);\n    }\n    tValues.push(1.0);\n    // add first and last control point if not present\n    if (colors[0].offset != 0.0) {\n      var c0 = {\n        offset: 0.0,\n        color: colors[0].color\n      };\n      colors.unshift(c0);\n    }\n    if (colors[colors.length - 1].offset != 1.0) {\n      var c1 = {\n        offset: 1.0,\n        color: colors[colors.length - 1].color\n      };\n      colors.push(c1);\n    }\n    var out = \"\";\n    var index = 0;\n\n    for (var i = 0; i < tValues.length; i++) {\n      t = tValues[i];\n      while (t > colors[index + 1].offset) index++;\n      var a = colors[index].offset;\n      var b = colors[index + 1].offset;\n      var d = (t - a) / (b - a);\n\n      var aColor = colors[index].color;\n      var bColor = colors[index + 1].color;\n\n      out +=\n        padd2Hex(Math.round((1 - d) * aColor[0] + d * bColor[0]).toString(16)) +\n        padd2Hex(Math.round((1 - d) * aColor[1] + d * bColor[1]).toString(16)) +\n        padd2Hex(Math.round((1 - d) * aColor[2] + d * bColor[2]).toString(16));\n    }\n    return out.trim();\n  };\n\n  var putShadingPattern = function(pattern, numberSamples) {\n    /*\n       Axial patterns shade between the two points specified in coords, radial patterns between the inner\n       and outer circle.\n       The user can specify an array (colors) that maps t-Values in [0, 1] to RGB colors. These are now\n       interpolated to equidistant samples and written to pdf as a sample (type 0) function.\n       */\n    // The number of color samples that should be used to describe the shading.\n    // The higher, the more accurate the gradient will be.\n    numberSamples || (numberSamples = 21);\n    var funcObjectNumber = newObject();\n    var stream = interpolateAndEncodeRGBStream(pattern.colors, numberSamples);\n\n    var options = [];\n    options.push({ key: \"FunctionType\", value: \"0\" });\n    options.push({ key: \"Domain\", value: \"[0.0 1.0]\" });\n    options.push({ key: \"Size\", value: \"[\" + numberSamples + \"]\" });\n    options.push({ key: \"BitsPerSample\", value: \"8\" });\n    options.push({ key: \"Range\", value: \"[0.0 1.0 0.0 1.0 0.0 1.0]\" });\n    options.push({ key: \"Decode\", value: \"[0.0 1.0 0.0 1.0 0.0 1.0]\" });\n\n    putStream({\n      data: stream,\n      additionalKeyValues: options,\n      alreadyAppliedFilters: [\"/ASCIIHexDecode\"],\n      objectId: funcObjectNumber\n    });\n    out(\"endobj\");\n\n    pattern.objectNumber = newObject();\n    out(\"<< /ShadingType \" + pattern.type);\n    out(\"/ColorSpace /DeviceRGB\");\n    var coords =\n      \"/Coords [\" +\n      hpf(parseFloat(pattern.coords[0])) +\n      \" \" + // x1\n      hpf(parseFloat(pattern.coords[1])) +\n      \" \"; // y1\n    if (pattern.type === 2) {\n      // axial\n      coords +=\n        hpf(parseFloat(pattern.coords[2])) +\n        \" \" + // x2\n        hpf(parseFloat(pattern.coords[3])); // y2\n    } else {\n      // radial\n      coords +=\n        hpf(parseFloat(pattern.coords[2])) +\n        \" \" + // r1\n        hpf(parseFloat(pattern.coords[3])) +\n        \" \" + // x2\n        hpf(parseFloat(pattern.coords[4])) +\n        \" \" + // y2\n        hpf(parseFloat(pattern.coords[5])); // r2\n    }\n    coords += \"]\";\n    out(coords);\n\n    if (pattern.matrix) {\n      out(\"/Matrix [\" + pattern.matrix.toString() + \"]\");\n    }\n    out(\"/Function \" + funcObjectNumber + \" 0 R\");\n    out(\"/Extend [true true]\");\n    out(\">>\");\n    out(\"endobj\");\n  };\n\n  var putTilingPattern = function(pattern, deferredResourceDictionaryIds) {\n    var resourcesObjectId = newObjectDeferred();\n    var patternObjectId = newObject();\n\n    deferredResourceDictionaryIds.push({\n      resourcesOid: resourcesObjectId,\n      objectOid: patternObjectId\n    });\n\n    pattern.objectNumber = patternObjectId;\n    var options = [];\n    options.push({ key: \"Type\", value: \"/Pattern\" });\n    options.push({ key: \"PatternType\", value: \"1\" }); // tiling pattern\n    options.push({ key: \"PaintType\", value: \"1\" }); // colored tiling pattern\n    options.push({ key: \"TilingType\", value: \"1\" }); // constant spacing\n    options.push({\n      key: \"BBox\",\n      value: \"[\" + pattern.boundingBox.map(hpf).join(\" \") + \"]\"\n    });\n    options.push({ key: \"XStep\", value: hpf(pattern.xStep) });\n    options.push({ key: \"YStep\", value: hpf(pattern.yStep) });\n    options.push({ key: \"Resources\", value: resourcesObjectId + \" 0 R\" });\n    if (pattern.matrix) {\n      options.push({\n        key: \"Matrix\",\n        value: \"[\" + pattern.matrix.toString() + \"]\"\n      });\n    }\n\n    putStream({\n      data: pattern.stream,\n      additionalKeyValues: options,\n      objectId: pattern.objectNumber\n    });\n    out(\"endobj\");\n  };\n\n  var putPatterns = function(deferredResourceDictionaryIds) {\n    var patternKey;\n    for (patternKey in patterns) {\n      if (patterns.hasOwnProperty(patternKey)) {\n        if (patterns[patternKey] instanceof ShadingPattern) {\n          putShadingPattern(patterns[patternKey]);\n        } else if (patterns[patternKey] instanceof TilingPattern) {\n          putTilingPattern(patterns[patternKey], deferredResourceDictionaryIds);\n        }\n      }\n    }\n  };\n\n  var putGState = function(gState) {\n    gState.objectNumber = newObject();\n    out(\"<<\");\n    for (var p in gState) {\n      switch (p) {\n        case \"opacity\":\n          out(\"/ca \" + f2(gState[p]));\n          break;\n        case \"stroke-opacity\":\n          out(\"/CA \" + f2(gState[p]));\n          break;\n      }\n    }\n    out(\">>\");\n    out(\"endobj\");\n  };\n\n  var putGStates = function() {\n    var gStateKey;\n    for (gStateKey in gStates) {\n      if (gStates.hasOwnProperty(gStateKey)) {\n        putGState(gStates[gStateKey]);\n      }\n    }\n  };\n\n  var putXobjectDict = function() {\n    out(\"/XObject <<\");\n    for (var xObjectKey in renderTargets) {\n      if (\n        renderTargets.hasOwnProperty(xObjectKey) &&\n        renderTargets[xObjectKey].objectNumber >= 0\n      ) {\n        out(\n          \"/\" +\n            xObjectKey +\n            \" \" +\n            renderTargets[xObjectKey].objectNumber +\n            \" 0 R\"\n        );\n      }\n    }\n\n    // Loop through images, or other data objects\n    events.publish(\"putXobjectDict\");\n    out(\">>\");\n  };\n\n  var putEncryptionDict = function() {\n    encryption.oid = newObject();\n    out(\"<<\");\n    out(\"/Filter /Standard\");\n    out(\"/V \" + encryption.v);\n    out(\"/R \" + encryption.r);\n    out(\"/U <\" + encryption.toHexString(encryption.U) + \">\");\n    out(\"/O <\" + encryption.toHexString(encryption.O) + \">\");\n    out(\"/P \" + encryption.P);\n    out(\">>\");\n    out(\"endobj\");\n  };\n\n  var putFontDict = function() {\n    out(\"/Font <<\");\n\n    for (var fontKey in fonts) {\n      if (fonts.hasOwnProperty(fontKey)) {\n        if (\n          putOnlyUsedFonts === false ||\n          (putOnlyUsedFonts === true && usedFonts.hasOwnProperty(fontKey))\n        ) {\n          out(\"/\" + fontKey + \" \" + fonts[fontKey].objectNumber + \" 0 R\");\n        }\n      }\n    }\n    out(\">>\");\n  };\n\n  var putShadingPatternDict = function() {\n    if (Object.keys(patterns).length > 0) {\n      out(\"/Shading <<\");\n      for (var patternKey in patterns) {\n        if (\n          patterns.hasOwnProperty(patternKey) &&\n          patterns[patternKey] instanceof ShadingPattern &&\n          patterns[patternKey].objectNumber >= 0\n        ) {\n          out(\n            \"/\" + patternKey + \" \" + patterns[patternKey].objectNumber + \" 0 R\"\n          );\n        }\n      }\n\n      events.publish(\"putShadingPatternDict\");\n      out(\">>\");\n    }\n  };\n\n  var putTilingPatternDict = function(objectOid) {\n    if (Object.keys(patterns).length > 0) {\n      out(\"/Pattern <<\");\n      for (var patternKey in patterns) {\n        if (\n          patterns.hasOwnProperty(patternKey) &&\n          patterns[patternKey] instanceof API.TilingPattern &&\n          patterns[patternKey].objectNumber >= 0 &&\n          patterns[patternKey].objectNumber < objectOid // prevent cyclic dependencies\n        ) {\n          out(\n            \"/\" + patternKey + \" \" + patterns[patternKey].objectNumber + \" 0 R\"\n          );\n        }\n      }\n      events.publish(\"putTilingPatternDict\");\n      out(\">>\");\n    }\n  };\n\n  var putGStatesDict = function() {\n    if (Object.keys(gStates).length > 0) {\n      var gStateKey;\n      out(\"/ExtGState <<\");\n      for (gStateKey in gStates) {\n        if (\n          gStates.hasOwnProperty(gStateKey) &&\n          gStates[gStateKey].objectNumber >= 0\n        ) {\n          out(\"/\" + gStateKey + \" \" + gStates[gStateKey].objectNumber + \" 0 R\");\n        }\n      }\n\n      events.publish(\"putGStateDict\");\n      out(\">>\");\n    }\n  };\n\n  var putResourceDictionary = function(objectIds) {\n    newObjectDeferredBegin(objectIds.resourcesOid, true);\n    out(\"<<\");\n    out(\"/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]\");\n    putFontDict();\n    putShadingPatternDict();\n    putTilingPatternDict(objectIds.objectOid);\n    putGStatesDict();\n    putXobjectDict();\n    out(\">>\");\n    out(\"endobj\");\n  };\n\n  var putResources = function() {\n    // FormObjects, Patterns etc. might use other FormObjects/Patterns/Images\n    // which means their resource dictionaries must contain the already resolved\n    // object ids. For this reason we defer the serialization of the resource\n    // dicts until all objects have been serialized and have object ids.\n    //\n    // In order to prevent cyclic dependencies (which Adobe Reader doesn't like),\n    // we only put all oids that are smaller than the oid of the object the\n    // resource dict belongs to. This is correct behavior, since the streams\n    // may only use other objects that have already been defined and thus appear\n    // earlier in their respective collection.\n    // Currently, this only affects tiling patterns, but a (more) correct\n    // implementation of FormObjects would also define their own resource dicts.\n    var deferredResourceDictionaryIds = [];\n\n    putFonts();\n    putGStates();\n    putXObjects();\n    putPatterns(deferredResourceDictionaryIds);\n\n    events.publish(\"putResources\");\n    deferredResourceDictionaryIds.forEach(putResourceDictionary);\n    putResourceDictionary({\n      resourcesOid: resourceDictionaryObjId,\n      objectOid: Number.MAX_SAFE_INTEGER // output all objects\n    });\n    events.publish(\"postPutResources\");\n  };\n\n  var putAdditionalObjects = function() {\n    events.publish(\"putAdditionalObjects\");\n    for (var i = 0; i < additionalObjects.length; i++) {\n      var obj = additionalObjects[i];\n      newObjectDeferredBegin(obj.objId, true);\n      out(obj.content);\n      out(\"endobj\");\n    }\n    events.publish(\"postPutAdditionalObjects\");\n  };\n\n  var addFontToFontDictionary = function(font) {\n    fontmap[font.fontName] = fontmap[font.fontName] || {};\n    fontmap[font.fontName][font.fontStyle] = font.id;\n  };\n\n  var addFont = function(\n    postScriptName,\n    fontName,\n    fontStyle,\n    encoding,\n    isStandardFont\n  ) {\n    var font = {\n      id: \"F\" + (Object.keys(fonts).length + 1).toString(10),\n      postScriptName: postScriptName,\n      fontName: fontName,\n      fontStyle: fontStyle,\n      encoding: encoding,\n      isStandardFont: isStandardFont || false,\n      metadata: {}\n    };\n\n    events.publish(\"addFont\", {\n      font: font,\n      instance: this\n    });\n\n    fonts[font.id] = font;\n    addFontToFontDictionary(font);\n    return font.id;\n  };\n\n  var addFonts = function(arrayOfFonts) {\n    for (var i = 0, l = standardFonts.length; i < l; i++) {\n      var fontKey = addFont.call(\n        this,\n        arrayOfFonts[i][0],\n        arrayOfFonts[i][1],\n        arrayOfFonts[i][2],\n        standardFonts[i][3],\n        true\n      );\n\n      if (putOnlyUsedFonts === false) {\n        usedFonts[fontKey] = true;\n      }\n      // adding aliases for standard fonts, this time matching the capitalization\n      var parts = arrayOfFonts[i][0].split(\"-\");\n      addFontToFontDictionary({\n        id: fontKey,\n        fontName: parts[0],\n        fontStyle: parts[1] || \"\"\n      });\n    }\n    events.publish(\"addFonts\", {\n      fonts: fonts,\n      dictionary: fontmap\n    });\n  };\n\n  var SAFE = function __safeCall(fn) {\n    fn.foo = function __safeCallWrapper() {\n      try {\n        return fn.apply(this, arguments);\n      } catch (e) {\n        var stack = e.stack || \"\";\n        if (~stack.indexOf(\" at \")) stack = stack.split(\" at \")[1];\n        var m =\n          \"Error in function \" +\n          stack.split(\"\\n\")[0].split(\"<\")[0] +\n          \": \" +\n          e.message;\n        if (globalObject.console) {\n          globalObject.console.error(m, e);\n          if (globalObject.alert) alert(m);\n        } else {\n          throw new Error(m);\n        }\n      }\n    };\n    fn.foo.bar = fn;\n    return fn.foo;\n  };\n\n  var to8bitStream = function(text, flags) {\n    /**\n     * PDF 1.3 spec:\n     * \"For text strings encoded in Unicode, the first two bytes must be 254 followed by\n     * 255, representing the Unicode byte order marker, U+FEFF. (This sequence conflicts\n     * with the PDFDocEncoding character sequence thorn ydieresis, which is unlikely\n     * to be a meaningful beginning of a word or phrase.) The remainder of the\n     * string consists of Unicode character codes, according to the UTF-16 encoding\n     * specified in the Unicode standard, version 2.0. Commonly used Unicode values\n     * are represented as 2 bytes per character, with the high-order byte appearing first\n     * in the string.\"\n     *\n     * In other words, if there are chars in a string with char code above 255, we\n     * recode the string to UCS2 BE - string doubles in length and BOM is prepended.\n     *\n     * HOWEVER!\n     * Actual *content* (body) text (as opposed to strings used in document properties etc)\n     * does NOT expect BOM. There, it is treated as a literal GID (Glyph ID)\n     *\n     * Because of Adobe's focus on \"you subset your fonts!\" you are not supposed to have\n     * a font that maps directly Unicode (UCS2 / UTF16BE) code to font GID, but you could\n     * fudge it with \"Identity-H\" encoding and custom CIDtoGID map that mimics Unicode\n     * code page. There, however, all characters in the stream are treated as GIDs,\n     * including BOM, which is the reason we need to skip BOM in content text (i.e. that\n     * that is tied to a font).\n     *\n     * To signal this \"special\" PDFEscape / to8bitStream handling mode,\n     * API.text() function sets (unless you overwrite it with manual values\n     * given to API.text(.., flags) )\n     * flags.autoencode = true\n     * flags.noBOM = true\n     *\n     * ===================================================================================\n     * `flags` properties relied upon:\n     *   .sourceEncoding = string with encoding label.\n     *                     \"Unicode\" by default. = encoding of the incoming text.\n     *                     pass some non-existing encoding name\n     *                     (ex: 'Do not touch my strings! I know what I am doing.')\n     *                     to make encoding code skip the encoding step.\n     *   .outputEncoding = Either valid PDF encoding name\n     *                     (must be supported by jsPDF font metrics, otherwise no encoding)\n     *                     or a JS object, where key = sourceCharCode, value = outputCharCode\n     *                     missing keys will be treated as: sourceCharCode === outputCharCode\n     *   .noBOM\n     *       See comment higher above for explanation for why this is important\n     *   .autoencode\n     *       See comment higher above for explanation for why this is important\n     */\n\n    var i,\n      l,\n      sourceEncoding,\n      encodingBlock,\n      outputEncoding,\n      newtext,\n      isUnicode,\n      ch,\n      bch;\n\n    flags = flags || {};\n    sourceEncoding = flags.sourceEncoding || \"Unicode\";\n    outputEncoding = flags.outputEncoding;\n\n    // This 'encoding' section relies on font metrics format\n    // attached to font objects by, among others,\n    // \"Willow Systems' standard_font_metrics plugin\"\n    // see jspdf.plugin.standard_font_metrics.js for format\n    // of the font.metadata.encoding Object.\n    // It should be something like\n    //   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}\n    //   .widths = {0:width, code:width, ..., 'fof':divisor}\n    //   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}\n    if (\n      (flags.autoencode || outputEncoding) &&\n      fonts[activeFontKey].metadata &&\n      fonts[activeFontKey].metadata[sourceEncoding] &&\n      fonts[activeFontKey].metadata[sourceEncoding].encoding\n    ) {\n      encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;\n\n      // each font has default encoding. Some have it clearly defined.\n      if (!outputEncoding && fonts[activeFontKey].encoding) {\n        outputEncoding = fonts[activeFontKey].encoding;\n      }\n\n      // Hmmm, the above did not work? Let's try again, in different place.\n      if (!outputEncoding && encodingBlock.codePages) {\n        outputEncoding = encodingBlock.codePages[0]; // let's say, first one is the default\n      }\n\n      if (typeof outputEncoding === \"string\") {\n        outputEncoding = encodingBlock[outputEncoding];\n      }\n      // we want output encoding to be a JS Object, where\n      // key = sourceEncoding's character code and\n      // value = outputEncoding's character code.\n      if (outputEncoding) {\n        isUnicode = false;\n        newtext = [];\n        for (i = 0, l = text.length; i < l; i++) {\n          ch = outputEncoding[text.charCodeAt(i)];\n          if (ch) {\n            newtext.push(String.fromCharCode(ch));\n          } else {\n            newtext.push(text[i]);\n          }\n\n          // since we are looping over chars anyway, might as well\n          // check for residual unicodeness\n          if (newtext[i].charCodeAt(0) >> 8) {\n            /* more than 255 */\n            isUnicode = true;\n          }\n        }\n        text = newtext.join(\"\");\n      }\n    }\n\n    i = text.length;\n    // isUnicode may be set to false above. Hence the triple-equal to undefined\n    while (isUnicode === undefined && i !== 0) {\n      if (text.charCodeAt(i - 1) >> 8) {\n        /* more than 255 */\n        isUnicode = true;\n      }\n      i--;\n    }\n    if (!isUnicode) {\n      return text;\n    }\n\n    newtext = flags.noBOM ? [] : [254, 255];\n    for (i = 0, l = text.length; i < l; i++) {\n      ch = text.charCodeAt(i);\n      bch = ch >> 8; // divide by 256\n      if (bch >> 8) {\n        /* something left after dividing by 256 second time */\n        throw new Error(\n          \"Character at position \" +\n            i +\n            \" of string '\" +\n            text +\n            \"' exceeds 16bits. Cannot be encoded into UCS-2 BE\"\n        );\n      }\n      newtext.push(bch);\n      newtext.push(ch - (bch << 8));\n    }\n    return String.fromCharCode.apply(undefined, newtext);\n  };\n\n  var pdfEscape = (API.__private__.pdfEscape = API.pdfEscape = function(\n    text,\n    flags\n  ) {\n    /**\n     * Replace '/', '(', and ')' with pdf-safe versions\n     *\n     * Doing to8bitStream does NOT make this PDF display unicode text. For that\n     * we also need to reference a unicode font and embed it - royal pain in the rear.\n     *\n     * There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,\n     * which JavaScript Strings are happy to provide. So, while we still cannot display\n     * 2-byte characters property, at least CONDITIONALLY converting (entire string containing)\n     * 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF\n     * is still parseable.\n     * This will allow immediate support for unicode in document properties strings.\n     */\n    return to8bitStream(text, flags)\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\(/g, \"\\\\(\")\n      .replace(/\\)/g, \"\\\\)\");\n  });\n\n  var beginPage = (API.__private__.beginPage = function(format) {\n    pages[++page] = [];\n    pagesContext[page] = {\n      objId: 0,\n      contentsObjId: 0,\n      userUnit: Number(userUnit),\n      artBox: null,\n      bleedBox: null,\n      cropBox: null,\n      trimBox: null,\n      mediaBox: {\n        bottomLeftX: 0,\n        bottomLeftY: 0,\n        topRightX: Number(format[0]),\n        topRightY: Number(format[1])\n      }\n    };\n    _setPage(page);\n    setOutputDestination(pages[currentPage]);\n  });\n\n  var _addPage = function(parmFormat, parmOrientation) {\n    var dimensions, width, height;\n\n    orientation = parmOrientation || orientation;\n\n    if (typeof parmFormat === \"string\") {\n      dimensions = getPageFormat(parmFormat.toLowerCase());\n      if (Array.isArray(dimensions)) {\n        width = dimensions[0];\n        height = dimensions[1];\n      }\n    }\n\n    if (Array.isArray(parmFormat)) {\n      width = parmFormat[0] * scaleFactor;\n      height = parmFormat[1] * scaleFactor;\n    }\n\n    if (isNaN(width)) {\n      width = format[0];\n      height = format[1];\n    }\n\n    if (width > 14400 || height > 14400) {\n      console.warn(\n        \"A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400\"\n      );\n      width = Math.min(14400, width);\n      height = Math.min(14400, height);\n    }\n\n    format = [width, height];\n\n    switch (orientation.substr(0, 1)) {\n      case \"l\":\n        if (height > width) {\n          format = [height, width];\n        }\n        break;\n      case \"p\":\n        if (width > height) {\n          format = [height, width];\n        }\n        break;\n    }\n\n    beginPage(format);\n\n    // Set line width\n    setLineWidth(lineWidth);\n    // Set draw color\n    out(strokeColor);\n    // resurrecting non-default line caps, joins\n    if (lineCapID !== 0) {\n      out(lineCapID + \" J\");\n    }\n    if (lineJoinID !== 0) {\n      out(lineJoinID + \" j\");\n    }\n    events.publish(\"addPage\", {\n      pageNumber: page\n    });\n  };\n\n  var _deletePage = function(n) {\n    if (n > 0 && n <= page) {\n      pages.splice(n, 1);\n      pagesContext.splice(n, 1);\n      page--;\n      if (currentPage > page) {\n        currentPage = page;\n      }\n      this.setPage(currentPage);\n    }\n  };\n\n  var _setPage = function(n) {\n    if (n > 0 && n <= page) {\n      currentPage = n;\n    }\n  };\n\n  var getNumberOfPages = (API.__private__.getNumberOfPages = API.getNumberOfPages = function() {\n    return pages.length - 1;\n  });\n\n  /**\n   * Returns a document-specific font key - a label assigned to a\n   * font name + font type combination at the time the font was added\n   * to the font inventory.\n   *\n   * Font key is used as label for the desired font for a block of text\n   * to be added to the PDF document stream.\n   * @private\n   * @function\n   * @param fontName {string} can be undefined on \"falthy\" to indicate \"use current\"\n   * @param fontStyle {string} can be undefined on \"falthy\" to indicate \"use current\"\n   * @returns {string} Font key.\n   * @ignore\n   */\n  var getFont = function(fontName, fontStyle, options) {\n    var key = undefined,\n      fontNameLowerCase;\n    options = options || {};\n\n    fontName =\n      fontName !== undefined ? fontName : fonts[activeFontKey].fontName;\n    fontStyle =\n      fontStyle !== undefined ? fontStyle : fonts[activeFontKey].fontStyle;\n    fontNameLowerCase = fontName.toLowerCase();\n\n    if (\n      fontmap[fontNameLowerCase] !== undefined &&\n      fontmap[fontNameLowerCase][fontStyle] !== undefined\n    ) {\n      key = fontmap[fontNameLowerCase][fontStyle];\n    } else if (\n      fontmap[fontName] !== undefined &&\n      fontmap[fontName][fontStyle] !== undefined\n    ) {\n      key = fontmap[fontName][fontStyle];\n    } else {\n      if (options.disableWarning === false) {\n        console.warn(\n          \"Unable to look up font label for font '\" +\n            fontName +\n            \"', '\" +\n            fontStyle +\n            \"'. Refer to getFontList() for available fonts.\"\n        );\n      }\n    }\n\n    if (!key && !options.noFallback) {\n      key = fontmap[\"times\"][fontStyle];\n      if (key == null) {\n        key = fontmap[\"times\"][\"normal\"];\n      }\n    }\n    return key;\n  };\n\n  var putInfo = (API.__private__.putInfo = function() {\n    var objectId = newObject();\n    var encryptor = function(data) {\n      return data;\n    };\n    if (encryptionOptions !== null) {\n      encryptor = encryption.encryptor(objectId, 0);\n    }\n    out(\"<<\");\n    out(\"/Producer (\" + pdfEscape(encryptor(\"jsPDF \" + jsPDF.version)) + \")\");\n    for (var key in documentProperties) {\n      if (documentProperties.hasOwnProperty(key) && documentProperties[key]) {\n        out(\n          \"/\" +\n            key.substr(0, 1).toUpperCase() +\n            key.substr(1) +\n            \" (\" +\n            pdfEscape(encryptor(documentProperties[key])) +\n            \")\"\n        );\n      }\n    }\n    out(\"/CreationDate (\" + pdfEscape(encryptor(creationDate)) + \")\");\n    out(\">>\");\n    out(\"endobj\");\n  });\n\n  var putCatalog = (API.__private__.putCatalog = function(options) {\n    options = options || {};\n    var tmpRootDictionaryObjId =\n      options.rootDictionaryObjId || rootDictionaryObjId;\n    newObject();\n    out(\"<<\");\n    out(\"/Type /Catalog\");\n    out(\"/Pages \" + tmpRootDictionaryObjId + \" 0 R\");\n    // PDF13ref Section 7.2.1\n    if (!zoomMode) zoomMode = \"fullwidth\";\n    switch (zoomMode) {\n      case \"fullwidth\":\n        out(\"/OpenAction [3 0 R /FitH null]\");\n        break;\n      case \"fullheight\":\n        out(\"/OpenAction [3 0 R /FitV null]\");\n        break;\n      case \"fullpage\":\n        out(\"/OpenAction [3 0 R /Fit]\");\n        break;\n      case \"original\":\n        out(\"/OpenAction [3 0 R /XYZ null null 1]\");\n        break;\n      default:\n        var pcn = \"\" + zoomMode;\n        if (pcn.substr(pcn.length - 1) === \"%\")\n          zoomMode = parseInt(zoomMode) / 100;\n        if (typeof zoomMode === \"number\") {\n          out(\"/OpenAction [3 0 R /XYZ null null \" + f2(zoomMode) + \"]\");\n        }\n    }\n    if (!layoutMode) layoutMode = \"continuous\";\n    switch (layoutMode) {\n      case \"continuous\":\n        out(\"/PageLayout /OneColumn\");\n        break;\n      case \"single\":\n        out(\"/PageLayout /SinglePage\");\n        break;\n      case \"two\":\n      case \"twoleft\":\n        out(\"/PageLayout /TwoColumnLeft\");\n        break;\n      case \"tworight\":\n        out(\"/PageLayout /TwoColumnRight\");\n        break;\n    }\n    if (pageMode) {\n      /**\n       * A name object specifying how the document should be displayed when opened:\n       * UseNone      : Neither document outline nor thumbnail images visible -- DEFAULT\n       * UseOutlines  : Document outline visible\n       * UseThumbs    : Thumbnail images visible\n       * FullScreen   : Full-screen mode, with no menu bar, window controls, or any other window visible\n       */\n      out(\"/PageMode /\" + pageMode);\n    }\n    events.publish(\"putCatalog\");\n    out(\">>\");\n    out(\"endobj\");\n  });\n\n  var putTrailer = (API.__private__.putTrailer = function() {\n    out(\"trailer\");\n    out(\"<<\");\n    out(\"/Size \" + (objectNumber + 1));\n    // Root and Info must be the last and second last objects written respectively\n    out(\"/Root \" + objectNumber + \" 0 R\");\n    out(\"/Info \" + (objectNumber - 1) + \" 0 R\");\n    if (encryptionOptions !== null) {\n      out(\"/Encrypt \" + encryption.oid + \" 0 R\");\n    }\n    out(\"/ID [ <\" + fileId + \"> <\" + fileId + \"> ]\");\n    out(\">>\");\n  });\n\n  var putHeader = (API.__private__.putHeader = function() {\n    out(\"%PDF-\" + pdfVersion);\n    out(\"%\\xBA\\xDF\\xAC\\xE0\");\n  });\n\n  var putXRef = (API.__private__.putXRef = function() {\n    var p = \"0000000000\";\n\n    out(\"xref\");\n    out(\"0 \" + (objectNumber + 1));\n    out(\"0000000000 65535 f \");\n    for (var i = 1; i <= objectNumber; i++) {\n      var offset = offsets[i];\n      if (typeof offset === \"function\") {\n        out((p + offsets[i]()).slice(-10) + \" 00000 n \");\n      } else {\n        if (typeof offsets[i] !== \"undefined\") {\n          out((p + offsets[i]).slice(-10) + \" 00000 n \");\n        } else {\n          out(\"0000000000 00000 n \");\n        }\n      }\n    }\n  });\n\n  var buildDocument = (API.__private__.buildDocument = function() {\n    resetDocument();\n    setOutputDestination(content);\n\n    events.publish(\"buildDocument\");\n\n    putHeader();\n    putPages();\n    putAdditionalObjects();\n    putResources();\n    if (encryptionOptions !== null) putEncryptionDict();\n    putInfo();\n    putCatalog();\n\n    var offsetOfXRef = contentLength;\n    putXRef();\n    putTrailer();\n    out(\"startxref\");\n    out(\"\" + offsetOfXRef);\n    out(\"%%EOF\");\n\n    setOutputDestination(pages[currentPage]);\n\n    return content.join(\"\\n\");\n  });\n\n  var getBlob = (API.__private__.getBlob = function(data) {\n    return new Blob([getArrayBuffer(data)], {\n      type: \"application/pdf\"\n    });\n  });\n\n  /**\n   * Generates the PDF document.\n   *\n   * If `type` argument is undefined, output is raw body of resulting PDF returned as a string.\n   *\n   * @param {string} type A string identifying one of the possible output types.<br/>\n   *                      Possible values are: <br/>\n   *                          'arraybuffer' -> (ArrayBuffer)<br/>\n   *                          'blob' -> (Blob)<br/>\n   *                          'bloburi'/'bloburl' -> (string)<br/>\n   *                          'datauristring'/'dataurlstring' -> (string)<br/>\n   *                          'datauri'/'dataurl' -> (undefined) -> change location to generated datauristring/dataurlstring<br/>\n   *                          'dataurlnewwindow' -> (window | null | undefined) throws error if global isn't a window object(node)<br/>\n   *                          'pdfobjectnewwindow' -> (window | null) throws error if global isn't a window object(node)<br/>\n   *                          'pdfjsnewwindow' -> (wind | null)\n   * @param {Object|string} options An object providing some additional signalling to PDF generator.<br/>\n   *                                Possible options are 'filename'.<br/>\n   *                                A string can be passed instead of {filename:string} and defaults to 'generated.pdf'\n   * @function\n   * @instance\n   * @returns {string|window|ArrayBuffer|Blob|jsPDF|null|undefined}\n   * @memberof jsPDF#\n   * @name output\n   */\n  var output = (API.output = API.__private__.output = SAFE(function output(\n    type,\n    options\n  ) {\n    options = options || {};\n\n    if (typeof options === \"string\") {\n      options = {\n        filename: options\n      };\n    } else {\n      options.filename = options.filename || \"generated.pdf\";\n    }\n\n    switch (type) {\n      case undefined:\n        return buildDocument();\n      case \"save\":\n        API.save(options.filename);\n        break;\n      case \"arraybuffer\":\n        return getArrayBuffer(buildDocument());\n      case \"blob\":\n        return getBlob(buildDocument());\n      case \"bloburi\":\n      case \"bloburl\":\n        // Developer is responsible of calling revokeObjectURL\n        if (\n          typeof globalObject.URL !== \"undefined\" &&\n          typeof globalObject.URL.createObjectURL === \"function\"\n        ) {\n          return (\n            (globalObject.URL &&\n              globalObject.URL.createObjectURL(getBlob(buildDocument()))) ||\n            void 0\n          );\n        } else {\n          console.warn(\n            \"bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.\"\n          );\n        }\n        break;\n      case \"datauristring\":\n      case \"dataurlstring\":\n        var dataURI = \"\";\n        var pdfDocument = buildDocument();\n        try {\n          dataURI = btoa(pdfDocument);\n        } catch (e) {\n          dataURI = btoa(unescape(encodeURIComponent(pdfDocument)));\n        }\n        return (\n          \"data:application/pdf;filename=\" +\n          options.filename +\n          \";base64,\" +\n          dataURI\n        );\n      case \"pdfobjectnewwindow\":\n        if (\n          Object.prototype.toString.call(globalObject) === \"[object Window]\"\n        ) {\n          var pdfObjectUrl =\n            options.pdfObjectUrl ||\n            \"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js\";\n          var htmlForNewWindow =\n            \"<html>\" +\n            '<style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src=\"' +\n            pdfObjectUrl +\n            '\"></script><script >PDFObject.embed(\"' +\n            this.output(\"dataurlstring\") +\n            '\", ' +\n            JSON.stringify(options) +\n            \");</script></body></html>\";\n          var nW = globalObject.open();\n\n          if (nW !== null) {\n            nW.document.write(htmlForNewWindow);\n          }\n          return nW;\n        } else {\n          throw new Error(\n            \"The option pdfobjectnewwindow just works in a browser-environment.\"\n          );\n        }\n      case \"pdfjsnewwindow\":\n        if (\n          Object.prototype.toString.call(globalObject) === \"[object Window]\"\n        ) {\n          var pdfJsUrl = options.pdfJsUrl || \"examples/PDF.js/web/viewer.html\";\n          var htmlForPDFjsNewWindow =\n            \"<html>\" +\n            \"<style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style>\" +\n            '<body><iframe id=\"pdfViewer\" src=\"' +\n            pdfJsUrl +\n            \"?file=&downloadName=\" +\n            options.filename +\n            '\" width=\"500px\" height=\"400px\" />' +\n            \"</body></html>\";\n          var PDFjsNewWindow = globalObject.open();\n\n          if (PDFjsNewWindow !== null) {\n            PDFjsNewWindow.document.write(htmlForPDFjsNewWindow);\n            var scope = this;\n            PDFjsNewWindow.document.documentElement.querySelector(\n              \"#pdfViewer\"\n            ).onload = function() {\n              PDFjsNewWindow.document.title = options.filename;\n              PDFjsNewWindow.document.documentElement\n                .querySelector(\"#pdfViewer\")\n                .contentWindow.PDFViewerApplication.open(\n                  scope.output(\"bloburl\")\n                );\n            };\n          }\n          return PDFjsNewWindow;\n        } else {\n          throw new Error(\n            \"The option pdfjsnewwindow just works in a browser-environment.\"\n          );\n        }\n      case \"dataurlnewwindow\":\n        if (\n          Object.prototype.toString.call(globalObject) === \"[object Window]\"\n        ) {\n          var htmlForDataURLNewWindow =\n            \"<html>\" +\n            \"<style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style>\" +\n            \"<body>\" +\n            '<iframe src=\"' +\n            this.output(\"datauristring\", options) +\n            '\"></iframe>' +\n            \"</body></html>\";\n          var dataURLNewWindow = globalObject.open();\n          if (dataURLNewWindow !== null) {\n            dataURLNewWindow.document.write(htmlForDataURLNewWindow);\n            dataURLNewWindow.document.title = options.filename;\n          }\n          if (dataURLNewWindow || typeof safari === \"undefined\")\n            return dataURLNewWindow;\n        } else {\n          throw new Error(\n            \"The option dataurlnewwindow just works in a browser-environment.\"\n          );\n        }\n        break;\n      case \"datauri\":\n      case \"dataurl\":\n        return (globalObject.document.location.href = this.output(\n          \"datauristring\",\n          options\n        ));\n      default:\n        return null;\n    }\n  }));\n\n  /**\n   * Used to see if a supplied hotfix was requested when the pdf instance was created.\n   * @param {string} hotfixName - The name of the hotfix to check.\n   * @returns {boolean}\n   */\n  var hasHotfix = function(hotfixName) {\n    return (\n      Array.isArray(hotfixes) === true && hotfixes.indexOf(hotfixName) > -1\n    );\n  };\n\n  switch (unit) {\n    case \"pt\":\n      scaleFactor = 1;\n      break;\n    case \"mm\":\n      scaleFactor = 72 / 25.4;\n      break;\n    case \"cm\":\n      scaleFactor = 72 / 2.54;\n      break;\n    case \"in\":\n      scaleFactor = 72;\n      break;\n    case \"px\":\n      if (hasHotfix(\"px_scaling\") == true) {\n        scaleFactor = 72 / 96;\n      } else {\n        scaleFactor = 96 / 72;\n      }\n      break;\n    case \"pc\":\n      scaleFactor = 12;\n      break;\n    case \"em\":\n      scaleFactor = 12;\n      break;\n    case \"ex\":\n      scaleFactor = 6;\n      break;\n    default:\n      throw new Error(\"Invalid unit: \" + unit);\n  }\n\n  var encryption = null;\n  setCreationDate();\n  setFileId();\n\n  var getEncryptor = function(objectId) {\n    if (encryptionOptions !== null) {\n      return encryption.encryptor(objectId, 0);\n    }\n    return function(data) {\n      return data;\n    };\n  };\n\n  //---------------------------------------\n  // Public API\n\n  var getPageInfo = (API.__private__.getPageInfo = API.getPageInfo = function(\n    pageNumberOneBased\n  ) {\n    if (isNaN(pageNumberOneBased) || pageNumberOneBased % 1 !== 0) {\n      throw new Error(\"Invalid argument passed to jsPDF.getPageInfo\");\n    }\n    var objId = pagesContext[pageNumberOneBased].objId;\n    return {\n      objId: objId,\n      pageNumber: pageNumberOneBased,\n      pageContext: pagesContext[pageNumberOneBased]\n    };\n  });\n\n  var getPageInfoByObjId = (API.__private__.getPageInfoByObjId = function(\n    objId\n  ) {\n    if (isNaN(objId) || objId % 1 !== 0) {\n      throw new Error(\"Invalid argument passed to jsPDF.getPageInfoByObjId\");\n    }\n    for (var pageNumber in pagesContext) {\n      if (pagesContext[pageNumber].objId === objId) {\n        break;\n      }\n    }\n    return getPageInfo(pageNumber);\n  });\n\n  var getCurrentPageInfo = (API.__private__.getCurrentPageInfo = API.getCurrentPageInfo = function() {\n    return {\n      objId: pagesContext[currentPage].objId,\n      pageNumber: currentPage,\n      pageContext: pagesContext[currentPage]\n    };\n  });\n\n  /**\n   * Adds (and transfers the focus to) new page to the PDF document.\n   * @param format {String/Array} The format of the new page. Can be: <ul><li>a0 - a10</li><li>b0 - b10</li><li>c0 - c10</li><li>dl</li><li>letter</li><li>government-letter</li><li>legal</li><li>junior-legal</li><li>ledger</li><li>tabloid</li><li>credit-card</li></ul><br />\n   * Default is \"a4\". If you want to use your own format just pass instead of one of the above predefined formats the size as an number-array, e.g. [595.28, 841.89]\n   * @param orientation {string} Orientation of the new page. Possible values are \"portrait\" or \"landscape\" (or shortcuts \"p\" (Default), \"l\").\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   *\n   * @memberof jsPDF#\n   * @name addPage\n   */\n  API.addPage = function() {\n    _addPage.apply(this, arguments);\n    return this;\n  };\n  /**\n   * Adds (and transfers the focus to) new page to the PDF document.\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   *\n   * @memberof jsPDF#\n   * @name setPage\n   * @param {number} page Switch the active page to the page number specified (indexed starting at 1).\n   * @example\n   * doc = jsPDF()\n   * doc.addPage()\n   * doc.addPage()\n   * doc.text('I am on page 3', 10, 10)\n   * doc.setPage(1)\n   * doc.text('I am on page 1', 10, 10)\n   */\n  API.setPage = function() {\n    _setPage.apply(this, arguments);\n    setOutputDestination.call(this, pages[currentPage]);\n    return this;\n  };\n\n  /**\n   * @name insertPage\n   * @memberof jsPDF#\n   *\n   * @function\n   * @instance\n   * @param {Object} beforePage\n   * @returns {jsPDF}\n   */\n  API.insertPage = function(beforePage) {\n    this.addPage();\n    this.movePage(currentPage, beforePage);\n    return this;\n  };\n\n  /**\n   * @name movePage\n   * @memberof jsPDF#\n   * @function\n   * @instance\n   * @param {number} targetPage\n   * @param {number} beforePage\n   * @returns {jsPDF}\n   */\n  API.movePage = function(targetPage, beforePage) {\n    var tmpPages, tmpPagesContext;\n    if (targetPage > beforePage) {\n      tmpPages = pages[targetPage];\n      tmpPagesContext = pagesContext[targetPage];\n      for (var i = targetPage; i > beforePage; i--) {\n        pages[i] = pages[i - 1];\n        pagesContext[i] = pagesContext[i - 1];\n      }\n      pages[beforePage] = tmpPages;\n      pagesContext[beforePage] = tmpPagesContext;\n      this.setPage(beforePage);\n    } else if (targetPage < beforePage) {\n      tmpPages = pages[targetPage];\n      tmpPagesContext = pagesContext[targetPage];\n      for (var j = targetPage; j < beforePage; j++) {\n        pages[j] = pages[j + 1];\n        pagesContext[j] = pagesContext[j + 1];\n      }\n      pages[beforePage] = tmpPages;\n      pagesContext[beforePage] = tmpPagesContext;\n      this.setPage(beforePage);\n    }\n    return this;\n  };\n\n  /**\n   * Deletes a page from the PDF.\n   * @name deletePage\n   * @memberof jsPDF#\n   * @function\n   * @param {number} targetPage\n   * @instance\n   * @returns {jsPDF}\n   */\n  API.deletePage = function() {\n    _deletePage.apply(this, arguments);\n    return this;\n  };\n\n  /**\n   * Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.\n   *\n   * @function\n   * @instance\n   * @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.\n   * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page.\n   * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page.\n   * @param {Object} [options] - Collection of settings signaling how the text must be encoded.\n   * @param {string} [options.align=left] - The alignment of the text, possible values: left, center, right, justify.\n   * @param {string} [options.baseline=alphabetic] - Sets text baseline used when drawing the text, possible values: alphabetic, ideographic, bottom, top, middle, hanging\n   * @param {number|Matrix} [options.angle=0] - Rotate the text clockwise or counterclockwise. Expects the angle in degree.\n   * @param {number} [options.rotationDirection=1] - Direction of the rotation. 0 = clockwise, 1 = counterclockwise.\n   * @param {number} [options.charSpace=0] - The space between each letter.\n   * @param {number} [options.lineHeightFactor=1.15] - The lineheight of each line.\n   * @param {Object} [options.flags] - Flags for to8bitStream.\n   * @param {boolean} [options.flags.noBOM=true] - Don't add BOM to Unicode-text.\n   * @param {boolean} [options.flags.autoencode=true] - Autoencode the Text.\n   * @param {number} [options.maxWidth=0] - Split the text by given width, 0 = no split.\n   * @param {string} [options.renderingMode=fill] - Set how the text should be rendered, possible values: fill, stroke, fillThenStroke, invisible, fillAndAddForClipping, strokeAndAddPathForClipping, fillThenStrokeAndAddToPathForClipping, addToPathForClipping.\n   * @param {boolean} [options.isInputVisual] - Option for the BidiEngine\n   * @param {boolean} [options.isOutputVisual] - Option for the BidiEngine\n   * @param {boolean} [options.isInputRtl] - Option for the BidiEngine\n   * @param {boolean} [options.isOutputRtl] - Option for the BidiEngine\n   * @param {boolean} [options.isSymmetricSwapping] - Option for the BidiEngine\n   * @param {number|Matrix} transform If transform is a number the text will be rotated by this value around the anchor set by x and y.\n   *\n   * If it is a Matrix, this matrix gets directly applied to the text, which allows shearing\n   * effects etc.; the x and y offsets are then applied AFTER the coordinate system has been established by this\n   * matrix. This means passing a rotation matrix that is equivalent to some rotation angle will in general yield a\n   * DIFFERENT result. A matrix is only allowed in \"advanced\" API mode.\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @name text\n   */\n  API.__private__.text = API.text = function(text, x, y, options, transform) {\n    /*\n     * Inserts something like this into PDF\n     *   BT\n     *    /F1 16 Tf  % Font name + size\n     *    16 TL % How many units down for next line in multiline text\n     *    0 g % color\n     *    28.35 813.54 Td % position\n     *    (line one) Tj\n     *    T* (line two) Tj\n     *    T* (line three) Tj\n     *   ET\n     */\n    options = options || {};\n    var scope = options.scope || this;\n    var payload, da, angle, align, charSpace, maxWidth, flags;\n\n    // Pre-August-2012 the order of arguments was function(x, y, text, flags)\n    // in effort to make all calls have similar signature like\n    //   function(data, coordinates... , miscellaneous)\n    // this method had its args flipped.\n    // code below allows backward compatibility with old arg order.\n    if (\n      typeof text === \"number\" &&\n      typeof x === \"number\" &&\n      (typeof y === \"string\" || Array.isArray(y))\n    ) {\n      var tmp = y;\n      y = x;\n      x = text;\n      text = tmp;\n    }\n\n    var transformationMatrix;\n\n    if (arguments[3] instanceof Matrix === false) {\n      flags = arguments[3];\n      angle = arguments[4];\n      align = arguments[5];\n\n      if (typeof flags !== \"object\" || flags === null) {\n        if (typeof angle === \"string\") {\n          align = angle;\n          angle = null;\n        }\n        if (typeof flags === \"string\") {\n          align = flags;\n          flags = null;\n        }\n        if (typeof flags === \"number\") {\n          angle = flags;\n          flags = null;\n        }\n        options = {\n          flags: flags,\n          angle: angle,\n          align: align\n        };\n      }\n    } else {\n      advancedApiModeTrap(\n        \"The transform parameter of text() with a Matrix value\"\n      );\n      transformationMatrix = transform;\n    }\n\n    if (isNaN(x) || isNaN(y) || typeof text === \"undefined\" || text === null) {\n      throw new Error(\"Invalid arguments passed to jsPDF.text\");\n    }\n\n    if (text.length === 0) {\n      return scope;\n    }\n\n    var xtra = \"\";\n    var isHex = false;\n    var lineHeight =\n      typeof options.lineHeightFactor === \"number\"\n        ? options.lineHeightFactor\n        : lineHeightFactor;\n    var scaleFactor = scope.internal.scaleFactor;\n\n    function ESC(s) {\n      s = s.split(\"\\t\").join(Array(options.TabLen || 9).join(\" \"));\n      return pdfEscape(s, flags);\n    }\n\n    function transformTextToSpecialArray(text) {\n      //we don't want to destroy original text array, so cloning it\n      var sa = text.concat();\n      var da = [];\n      var len = sa.length;\n      var curDa;\n      //we do array.join('text that must not be PDFescaped\")\n      //thus, pdfEscape each component separately\n      while (len--) {\n        curDa = sa.shift();\n        if (typeof curDa === \"string\") {\n          da.push(curDa);\n        } else {\n          if (\n            Array.isArray(text) &&\n            (curDa.length === 1 ||\n              (curDa[1] === undefined && curDa[2] === undefined))\n          ) {\n            da.push(curDa[0]);\n          } else {\n            da.push([curDa[0], curDa[1], curDa[2]]);\n          }\n        }\n      }\n      return da;\n    }\n\n    function processTextByFunction(text, processingFunction) {\n      var result;\n      if (typeof text === \"string\") {\n        result = processingFunction(text)[0];\n      } else if (Array.isArray(text)) {\n        //we don't want to destroy original text array, so cloning it\n        var sa = text.concat();\n        var da = [];\n        var len = sa.length;\n        var curDa;\n        var tmpResult;\n        //we do array.join('text that must not be PDFescaped\")\n        //thus, pdfEscape each component separately\n        while (len--) {\n          curDa = sa.shift();\n          if (typeof curDa === \"string\") {\n            da.push(processingFunction(curDa)[0]);\n          } else if (Array.isArray(curDa) && typeof curDa[0] === \"string\") {\n            tmpResult = processingFunction(curDa[0], curDa[1], curDa[2]);\n            da.push([tmpResult[0], tmpResult[1], tmpResult[2]]);\n          }\n        }\n        result = da;\n      }\n      return result;\n    }\n\n    //Check if text is of type String\n    var textIsOfTypeString = false;\n    var tmpTextIsOfTypeString = true;\n\n    if (typeof text === \"string\") {\n      textIsOfTypeString = true;\n    } else if (Array.isArray(text)) {\n      //we don't want to destroy original text array, so cloning it\n      var sa = text.concat();\n      da = [];\n      var len = sa.length;\n      var curDa;\n      //we do array.join('text that must not be PDFescaped\")\n      //thus, pdfEscape each component separately\n      while (len--) {\n        curDa = sa.shift();\n        if (\n          typeof curDa !== \"string\" ||\n          (Array.isArray(curDa) && typeof curDa[0] !== \"string\")\n        ) {\n          tmpTextIsOfTypeString = false;\n        }\n      }\n      textIsOfTypeString = tmpTextIsOfTypeString;\n    }\n    if (textIsOfTypeString === false) {\n      throw new Error(\n        'Type of text must be string or Array. \"' +\n          text +\n          '\" is not recognized.'\n      );\n    }\n\n    //If there are any newlines in text, we assume\n    //the user wanted to print multiple lines, so break the\n    //text up into an array. If the text is already an array,\n    //we assume the user knows what they are doing.\n    //Convert text into an array anyway to simplify\n    //later code.\n\n    if (typeof text === \"string\") {\n      if (text.match(/[\\r?\\n]/)) {\n        text = text.split(/\\r\\n|\\r|\\n/g);\n      } else {\n        text = [text];\n      }\n    }\n\n    //baseline\n    var height = activeFontSize / scope.internal.scaleFactor;\n    var descent = height * (lineHeightFactor - 1);\n    switch (options.baseline) {\n      case \"bottom\":\n        y -= descent;\n        break;\n      case \"top\":\n        y += height - descent;\n        break;\n      case \"hanging\":\n        y += height - 2 * descent;\n        break;\n      case \"middle\":\n        y += height / 2 - descent;\n        break;\n      case \"ideographic\":\n      case \"alphabetic\":\n      default:\n        // do nothing, everything is fine\n        break;\n    }\n\n    //multiline\n    maxWidth = options.maxWidth || 0;\n\n    if (maxWidth > 0) {\n      if (typeof text === \"string\") {\n        text = scope.splitTextToSize(text, maxWidth);\n      } else if (Object.prototype.toString.call(text) === \"[object Array]\") {\n        text = text.reduce(function(acc, textLine) {\n          return acc.concat(scope.splitTextToSize(textLine, maxWidth));\n        }, []);\n      }\n    }\n\n    //creating Payload-Object to make text byRef\n    payload = {\n      text: text,\n      x: x,\n      y: y,\n      options: options,\n      mutex: {\n        pdfEscape: pdfEscape,\n        activeFontKey: activeFontKey,\n        fonts: fonts,\n        activeFontSize: activeFontSize\n      }\n    };\n    events.publish(\"preProcessText\", payload);\n\n    text = payload.text;\n    options = payload.options;\n\n    //angle\n    angle = options.angle;\n\n    if (\n      transformationMatrix instanceof Matrix === false &&\n      angle &&\n      typeof angle === \"number\"\n    ) {\n      angle *= Math.PI / 180;\n\n      if (options.rotationDirection === 0) {\n        angle = -angle;\n      }\n\n      if (apiMode === ApiMode.ADVANCED) {\n        angle = -angle;\n      }\n\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      transformationMatrix = new Matrix(c, s, -s, c, 0, 0);\n    } else if (angle && angle instanceof Matrix) {\n      transformationMatrix = angle;\n    }\n\n    if (apiMode === ApiMode.ADVANCED && !transformationMatrix) {\n      transformationMatrix = identityMatrix;\n    }\n\n    //charSpace\n\n    charSpace = options.charSpace || activeCharSpace;\n\n    if (typeof charSpace !== \"undefined\") {\n      xtra += hpf(scale(charSpace)) + \" Tc\\n\";\n      this.setCharSpace(this.getCharSpace() || 0);\n    }\n\n    //lang\n\n    var lang = options.lang;\n\n    if (lang) {\n      //    xtra += \"/Lang (\" + lang +\")\\n\";\n    }\n\n    //renderingMode\n    var renderingMode = -1;\n    var parmRenderingMode =\n      typeof options.renderingMode !== \"undefined\"\n        ? options.renderingMode\n        : options.stroke;\n    var pageContext = scope.internal.getCurrentPageInfo().pageContext;\n\n    switch (parmRenderingMode) {\n      case 0:\n      case false:\n      case \"fill\":\n        renderingMode = 0;\n        break;\n      case 1:\n      case true:\n      case \"stroke\":\n        renderingMode = 1;\n        break;\n      case 2:\n      case \"fillThenStroke\":\n        renderingMode = 2;\n        break;\n      case 3:\n      case \"invisible\":\n        renderingMode = 3;\n        break;\n      case 4:\n      case \"fillAndAddForClipping\":\n        renderingMode = 4;\n        break;\n      case 5:\n      case \"strokeAndAddPathForClipping\":\n        renderingMode = 5;\n        break;\n      case 6:\n      case \"fillThenStrokeAndAddToPathForClipping\":\n        renderingMode = 6;\n        break;\n      case 7:\n      case \"addToPathForClipping\":\n        renderingMode = 7;\n        break;\n    }\n\n    var usedRenderingMode =\n      typeof pageContext.usedRenderingMode !== \"undefined\"\n        ? pageContext.usedRenderingMode\n        : -1;\n\n    //if the coder wrote it explicitly to use a specific\n    //renderingMode, then use it\n    if (renderingMode !== -1) {\n      xtra += renderingMode + \" Tr\\n\";\n      //otherwise check if we used the rendering Mode already\n      //if so then set the rendering Mode...\n    } else if (usedRenderingMode !== -1) {\n      xtra += \"0 Tr\\n\";\n    }\n\n    if (renderingMode !== -1) {\n      pageContext.usedRenderingMode = renderingMode;\n    }\n\n    //align\n    align = options.align || \"left\";\n    var leading = activeFontSize * lineHeight;\n    var pageWidth = scope.internal.pageSize.getWidth();\n    var activeFont = fonts[activeFontKey];\n    charSpace = options.charSpace || activeCharSpace;\n    maxWidth = options.maxWidth || 0;\n\n    var lineWidths;\n    flags = Object.assign({ autoencode: true, noBOM: true }, options.flags);\n\n    var wordSpacingPerLine = [];\n\n    if (Object.prototype.toString.call(text) === \"[object Array]\") {\n      da = transformTextToSpecialArray(text);\n      var newY;\n      if (align !== \"left\") {\n        lineWidths = da.map(function(v) {\n          return (\n            (scope.getStringUnitWidth(v, {\n              font: activeFont,\n              charSpace: charSpace,\n              fontSize: activeFontSize,\n              doKerning: false\n            }) *\n              activeFontSize) /\n            scaleFactor\n          );\n        });\n      }\n      //The first line uses the \"main\" Td setting,\n      //and the subsequent lines are offset by the\n      //previous line's x coordinate.\n      var prevWidth = 0;\n      var newX;\n      if (align === \"right\") {\n        //The passed in x coordinate defines the\n        //rightmost point of the text.\n        x -= lineWidths[0];\n        text = [];\n        len = da.length;\n        for (var i = 0; i < len; i++) {\n          if (i === 0) {\n            newX = getHorizontalCoordinate(x);\n            newY = getVerticalCoordinate(y);\n          } else {\n            newX = scale(prevWidth - lineWidths[i]);\n            newY = -leading;\n          }\n          text.push([da[i], newX, newY]);\n          prevWidth = lineWidths[i];\n        }\n      } else if (align === \"center\") {\n        //The passed in x coordinate defines\n        //the center point.\n        x -= lineWidths[0] / 2;\n        text = [];\n        len = da.length;\n        for (var j = 0; j < len; j++) {\n          if (j === 0) {\n            newX = getHorizontalCoordinate(x);\n            newY = getVerticalCoordinate(y);\n          } else {\n            newX = scale((prevWidth - lineWidths[j]) / 2);\n            newY = -leading;\n          }\n          text.push([da[j], newX, newY]);\n          prevWidth = lineWidths[j];\n        }\n      } else if (align === \"left\") {\n        text = [];\n        len = da.length;\n        for (var h = 0; h < len; h++) {\n          text.push(da[h]);\n        }\n      } else if (align === \"justify\") {\n        text = [];\n        len = da.length;\n        maxWidth = maxWidth !== 0 ? maxWidth : pageWidth;\n\n        for (var l = 0; l < len; l++) {\n          newY = l === 0 ? getVerticalCoordinate(y) : -leading;\n          newX = l === 0 ? getHorizontalCoordinate(x) : 0;\n          if (l < len - 1) {\n            wordSpacingPerLine.push(\n              hpf(\n                scale(\n                  (maxWidth - lineWidths[l]) / (da[l].split(\" \").length - 1)\n                )\n              )\n            );\n          } else {\n            wordSpacingPerLine.push(0);\n          }\n          text.push([da[l], newX, newY]);\n        }\n      } else {\n        throw new Error(\n          'Unrecognized alignment option, use \"left\", \"center\", \"right\" or \"justify\".'\n        );\n      }\n    }\n\n    //R2L\n    var doReversing = typeof options.R2L === \"boolean\" ? options.R2L : R2L;\n    if (doReversing === true) {\n      text = processTextByFunction(text, function(text, posX, posY) {\n        return [\n          text\n            .split(\"\")\n            .reverse()\n            .join(\"\"),\n          posX,\n          posY\n        ];\n      });\n    }\n\n    //creating Payload-Object to make text byRef\n    payload = {\n      text: text,\n      x: x,\n      y: y,\n      options: options,\n      mutex: {\n        pdfEscape: pdfEscape,\n        activeFontKey: activeFontKey,\n        fonts: fonts,\n        activeFontSize: activeFontSize\n      }\n    };\n    events.publish(\"postProcessText\", payload);\n\n    text = payload.text;\n    isHex = payload.mutex.isHex || false;\n\n    //Escaping\n    var activeFontEncoding = fonts[activeFontKey].encoding;\n\n    if (\n      activeFontEncoding === \"WinAnsiEncoding\" ||\n      activeFontEncoding === \"StandardEncoding\"\n    ) {\n      text = processTextByFunction(text, function(text, posX, posY) {\n        return [ESC(text), posX, posY];\n      });\n    }\n\n    da = transformTextToSpecialArray(text);\n\n    text = [];\n    var STRING = 0;\n    var ARRAY = 1;\n    var variant = Array.isArray(da[0]) ? ARRAY : STRING;\n    var posX;\n    var posY;\n    var content;\n    var wordSpacing = \"\";\n\n    var generatePosition = function(\n      parmPosX,\n      parmPosY,\n      parmTransformationMatrix\n    ) {\n      var position = \"\";\n      if (parmTransformationMatrix instanceof Matrix) {\n        // It is kind of more intuitive to apply a plain rotation around the text anchor set by x and y\n        // but when the user supplies an arbitrary transformation matrix, the x and y offsets should be applied\n        // in the coordinate system established by this matrix\n        if (typeof options.angle === \"number\") {\n          parmTransformationMatrix = matrixMult(\n            parmTransformationMatrix,\n            new Matrix(1, 0, 0, 1, parmPosX, parmPosY)\n          );\n        } else {\n          parmTransformationMatrix = matrixMult(\n            new Matrix(1, 0, 0, 1, parmPosX, parmPosY),\n            parmTransformationMatrix\n          );\n        }\n\n        if (apiMode === ApiMode.ADVANCED) {\n          parmTransformationMatrix = matrixMult(\n            new Matrix(1, 0, 0, -1, 0, 0),\n            parmTransformationMatrix\n          );\n        }\n\n        position = parmTransformationMatrix.join(\" \") + \" Tm\\n\";\n      } else {\n        position = hpf(parmPosX) + \" \" + hpf(parmPosY) + \" Td\\n\";\n      }\n      return position;\n    };\n\n    for (var lineIndex = 0; lineIndex < da.length; lineIndex++) {\n      wordSpacing = \"\";\n\n      switch (variant) {\n        case ARRAY:\n          content =\n            (isHex ? \"<\" : \"(\") + da[lineIndex][0] + (isHex ? \">\" : \")\");\n          posX = parseFloat(da[lineIndex][1]);\n          posY = parseFloat(da[lineIndex][2]);\n          break;\n        case STRING:\n          content = (isHex ? \"<\" : \"(\") + da[lineIndex] + (isHex ? \">\" : \")\");\n          posX = getHorizontalCoordinate(x);\n          posY = getVerticalCoordinate(y);\n          break;\n      }\n\n      if (\n        typeof wordSpacingPerLine !== \"undefined\" &&\n        typeof wordSpacingPerLine[lineIndex] !== \"undefined\"\n      ) {\n        wordSpacing = wordSpacingPerLine[lineIndex] + \" Tw\\n\";\n      }\n\n      if (lineIndex === 0) {\n        text.push(\n          wordSpacing +\n            generatePosition(posX, posY, transformationMatrix) +\n            content\n        );\n      } else if (variant === STRING) {\n        text.push(wordSpacing + content);\n      } else if (variant === ARRAY) {\n        text.push(\n          wordSpacing +\n            generatePosition(posX, posY, transformationMatrix) +\n            content\n        );\n      }\n    }\n\n    text = variant === STRING ? text.join(\" Tj\\nT* \") : text.join(\" Tj\\n\");\n    text += \" Tj\\n\";\n\n    var result = \"BT\\n/\";\n    result += activeFontKey + \" \" + activeFontSize + \" Tf\\n\"; // font face, style, size\n    result += hpf(activeFontSize * lineHeight) + \" TL\\n\"; // line spacing\n    result += textColor + \"\\n\";\n    result += xtra;\n    result += text;\n    result += \"ET\";\n\n    out(result);\n    usedFonts[activeFontKey] = true;\n    return scope;\n  };\n\n  // PDF supports these path painting and clip path operators:\n  //\n  // S - stroke\n  // s - close/stroke\n  // f (F) - fill non-zero\n  // f* - fill evenodd\n  // B - fill stroke nonzero\n  // B* - fill stroke evenodd\n  // b - close fill stroke nonzero\n  // b* - close fill stroke evenodd\n  // n - nothing (consume path)\n  // W - clip nonzero\n  // W* - clip evenodd\n  //\n  // In order to keep the API small, we omit the close-and-fill/stroke operators and provide a separate close()\n  // method.\n  /**\n   *\n   * @name clip\n   * @function\n   * @instance\n   * @param {string} rule Only possible value is 'evenodd'\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @description All .clip() after calling drawing ops with a style argument of null.\n   */\n  var clip = (API.__private__.clip = API.clip = function(rule) {\n    // Call .clip() after calling drawing ops with a style argument of null\n    // W is the PDF clipping op\n    if (\"evenodd\" === rule) {\n      out(\"W*\");\n    } else {\n      out(\"W\");\n    }\n    return this;\n  });\n\n  /**\n   * @name clipEvenOdd\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @description Modify the current clip path by intersecting it with the current path using the even-odd rule. Note\n   * that this will NOT consume the current path. In order to only use this path for clipping call\n   * {@link API.discardPath} afterwards.\n   */\n  API.clipEvenOdd = function() {\n    return clip(\"evenodd\");\n  };\n\n  /**\n   * Consumes the current path without any effect. Mainly used in combination with {@link clip} or\n   * {@link clipEvenOdd}. The PDF \"n\" operator.\n   * @name discardPath\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   */\n  API.__private__.discardPath = API.discardPath = function() {\n    out(\"n\");\n    return this;\n  };\n\n  var isValidStyle = (API.__private__.isValidStyle = function(style) {\n    var validStyleVariants = [\n      undefined,\n      null,\n      \"S\",\n      \"D\",\n      \"F\",\n      \"DF\",\n      \"FD\",\n      \"f\",\n      \"f*\",\n      \"B\",\n      \"B*\",\n      \"n\"\n    ];\n    var result = false;\n    if (validStyleVariants.indexOf(style) !== -1) {\n      result = true;\n    }\n    return result;\n  });\n\n  API.__private__.setDefaultPathOperation = API.setDefaultPathOperation = function(\n    operator\n  ) {\n    if (isValidStyle(operator)) {\n      defaultPathOperation = operator;\n    }\n    return this;\n  };\n\n  var getStyle = (API.__private__.getStyle = API.getStyle = function(style) {\n    // see path-painting operators in PDF spec\n    var op = defaultPathOperation; // stroke\n\n    switch (style) {\n      case \"D\":\n      case \"S\":\n        op = \"S\"; // stroke\n        break;\n      case \"F\":\n        op = \"f\"; // fill\n        break;\n      case \"FD\":\n      case \"DF\":\n        op = \"B\";\n        break;\n      case \"f\":\n      case \"f*\":\n      case \"B\":\n      case \"B*\":\n        /*\n               Allow direct use of these PDF path-painting operators:\n               - f    fill using nonzero winding number rule\n               - f*    fill using even-odd rule\n               - B    fill then stroke with fill using non-zero winding number rule\n               - B*    fill then stroke with fill using even-odd rule\n               */\n        op = style;\n        break;\n    }\n    return op;\n  });\n\n  /**\n   * Close the current path. The PDF \"h\" operator.\n   * @name close\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   */\n  var close = (API.close = function() {\n    out(\"h\");\n    return this;\n  });\n\n  /**\n   * Stroke the path. The PDF \"S\" operator.\n   * @name stroke\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   */\n  API.stroke = function() {\n    out(\"S\");\n    return this;\n  };\n\n  /**\n   * Fill the current path using the nonzero winding number rule. If a pattern is provided, the path will be filled\n   * with this pattern, otherwise with the current fill color. Equivalent to the PDF \"f\" operator.\n   * @name fill\n   * @function\n   * @instance\n   * @param {PatternData=} pattern If provided the path will be filled with this pattern\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   */\n  API.fill = function(pattern) {\n    fillWithOptionalPattern(\"f\", pattern);\n    return this;\n  };\n\n  /**\n   * Fill the current path using the even-odd rule. The PDF f* operator.\n   * @see API.fill\n   * @name fillEvenOdd\n   * @function\n   * @instance\n   * @param {PatternData=} pattern If provided the path will be filled with this pattern\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   */\n  API.fillEvenOdd = function(pattern) {\n    fillWithOptionalPattern(\"f*\", pattern);\n    return this;\n  };\n\n  /**\n   * Fill using the nonzero winding number rule and then stroke the current Path. The PDF \"B\" operator.\n   * @see API.fill\n   * @name fillStroke\n   * @function\n   * @instance\n   * @param {PatternData=} pattern If provided the path will be stroked with this pattern\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   */\n  API.fillStroke = function(pattern) {\n    fillWithOptionalPattern(\"B\", pattern);\n    return this;\n  };\n\n  /**\n   * Fill using the even-odd rule and then stroke the current Path. The PDF \"B\" operator.\n   * @see API.fill\n   * @name fillStrokeEvenOdd\n   * @function\n   * @instance\n   * @param {PatternData=} pattern If provided the path will be fill-stroked with this pattern\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   */\n  API.fillStrokeEvenOdd = function(pattern) {\n    fillWithOptionalPattern(\"B*\", pattern);\n    return this;\n  };\n\n  var fillWithOptionalPattern = function(style, pattern) {\n    if (typeof pattern === \"object\") {\n      fillWithPattern(pattern, style);\n    } else {\n      out(style);\n    }\n  };\n\n  var putStyle = function(style) {\n    if (\n      style === null ||\n      (apiMode === ApiMode.ADVANCED && style === undefined)\n    ) {\n      return;\n    }\n\n    style = getStyle(style);\n\n    // stroking / filling / both the path\n    out(style);\n  };\n\n  function cloneTilingPattern(patternKey, boundingBox, xStep, yStep, matrix) {\n    var clone = new TilingPattern(\n      boundingBox || this.boundingBox,\n      xStep || this.xStep,\n      yStep || this.yStep,\n      this.gState,\n      matrix || this.matrix\n    );\n    clone.stream = this.stream;\n    var key = patternKey + \"$$\" + this.cloneIndex++ + \"$$\";\n    addPattern(key, clone);\n    return clone;\n  }\n\n  var fillWithPattern = function(patternData, style) {\n    var patternId = patternMap[patternData.key];\n    var pattern = patterns[patternId];\n\n    if (pattern instanceof ShadingPattern) {\n      out(\"q\");\n\n      out(clipRuleFromStyle(style));\n\n      if (pattern.gState) {\n        API.setGState(pattern.gState);\n      }\n      out(patternData.matrix.toString() + \" cm\");\n      out(\"/\" + patternId + \" sh\");\n      out(\"Q\");\n    } else if (pattern instanceof TilingPattern) {\n      // pdf draws patterns starting at the bottom left corner and they are not affected by the global transformation,\n      // so we must flip them\n      var matrix = new Matrix(1, 0, 0, -1, 0, getPageHeight());\n\n      if (patternData.matrix) {\n        matrix = matrix.multiply(patternData.matrix || identityMatrix);\n        // we cannot apply a matrix to the pattern on use so we must abuse the pattern matrix and create new instances\n        // for each use\n        patternId = cloneTilingPattern.call(\n          pattern,\n          patternData.key,\n          patternData.boundingBox,\n          patternData.xStep,\n          patternData.yStep,\n          matrix\n        ).id;\n      }\n\n      out(\"q\");\n      out(\"/Pattern cs\");\n      out(\"/\" + patternId + \" scn\");\n\n      if (pattern.gState) {\n        API.setGState(pattern.gState);\n      }\n\n      out(style);\n      out(\"Q\");\n    }\n  };\n\n  var clipRuleFromStyle = function(style) {\n    switch (style) {\n      case \"f\":\n      case \"F\":\n        return \"W n\";\n      case \"f*\":\n        return \"W* n\";\n      case \"B\":\n        return \"W S\";\n      case \"B*\":\n        return \"W* S\";\n\n      // these two are for compatibility reasons (in the past, calling any primitive method with a shading pattern\n      // and \"n\"/\"S\" as style would still fill/fill and stroke the path)\n      case \"S\":\n        return \"W S\";\n      case \"n\":\n        return \"W n\";\n    }\n  };\n\n  /**\n   * Begin a new subpath by moving the current point to coordinates (x, y). The PDF \"m\" operator.\n   * @param {number} x\n   * @param {number} y\n   * @name moveTo\n   * @function\n   * @instance\n   * @memberof jsPDF#\n   * @returns {jsPDF}\n   */\n  var moveTo = (API.moveTo = function(x, y) {\n    out(hpf(scale(x)) + \" \" + hpf(transformScaleY(y)) + \" m\");\n    return this;\n  });\n\n  /**\n   * Append a straight line segment from the current point to the point (x, y). The PDF \"l\" operator.\n   * @param {number} x\n   * @param {number} y\n   * @memberof jsPDF#\n   * @name lineTo\n   * @function\n   * @instance\n   * @memberof jsPDF#\n   * @returns {jsPDF}\n   */\n  var lineTo = (API.lineTo = function(x, y) {\n    out(hpf(scale(x)) + \" \" + hpf(transformScaleY(y)) + \" l\");\n    return this;\n  });\n\n  /**\n   * Append a cubic Bézier curve to the current path. The curve shall extend from the current point to the point\n   * (x3, y3), using (x1, y1) and (x2, y2) as Bézier control points. The new current point shall be (x3, x3).\n   * @param {number} x1\n   * @param {number} y1\n   * @param {number} x2\n   * @param {number} y2\n   * @param {number} x3\n   * @param {number} y3\n   * @memberof jsPDF#\n   * @name curveTo\n   * @function\n   * @instance\n   * @memberof jsPDF#\n   * @returns {jsPDF}\n   */\n  var curveTo = (API.curveTo = function(x1, y1, x2, y2, x3, y3) {\n    out(\n      [\n        hpf(scale(x1)),\n        hpf(transformScaleY(y1)),\n        hpf(scale(x2)),\n        hpf(transformScaleY(y2)),\n        hpf(scale(x3)),\n        hpf(transformScaleY(y3)),\n        \"c\"\n      ].join(\" \")\n    );\n    return this;\n  });\n\n  /**\n   * Draw a line on the current page.\n   *\n   * @name line\n   * @function\n   * @instance\n   * @param {number} x1\n   * @param {number} y1\n   * @param {number} x2\n   * @param {number} y2\n   * @param {string} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument. default: 'S'\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   */\n  API.__private__.line = API.line = function(x1, y1, x2, y2, style) {\n    if (\n      isNaN(x1) ||\n      isNaN(y1) ||\n      isNaN(x2) ||\n      isNaN(y2) ||\n      !isValidStyle(style)\n    ) {\n      throw new Error(\"Invalid arguments passed to jsPDF.line\");\n    }\n    if (apiMode === ApiMode.COMPAT) {\n      return this.lines([[x2 - x1, y2 - y1]], x1, y1, [1, 1], style || \"S\");\n    } else {\n      return this.lines([[x2 - x1, y2 - y1]], x1, y1, [1, 1]).stroke();\n    }\n  };\n\n  /**\n   * @typedef {Object} PatternData\n   * {Matrix|undefined} matrix\n   * {Number|undefined} xStep\n   * {Number|undefined} yStep\n   * {Array.<Number>|undefined} boundingBox\n   */\n\n  /**\n   * Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.\n   * All data points in `lines` are relative to last line origin.\n   * `x`, `y` become x1,y1 for first line / curve in the set.\n   * For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.\n   * For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.\n   *\n   * @example .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, [1,1], 'F', false) // line, line, bezier curve, line\n   * @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).\n   * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page\n   * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n   * @param {number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.\n   * @param {string=} style A string specifying the painting style or null. Valid styles include:\n   * 'S' [default] - stroke,\n   * 'F' - fill,\n   * and 'DF' (or 'FD') -  fill then stroke.\n   * In \"compat\" API mode, a null value postpones setting the style so that a shape may be composed using multiple\n   * method calls. The last drawing method call used to define the shape should not have a null style argument.\n   *\n   * In \"advanced\" API mode this parameter is deprecated.\n   * @param {Boolean=} closed If true, the path is closed with a straight line from the end of the last curve to the starting point.\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @name lines\n   */\n  API.__private__.lines = API.lines = function(\n    lines,\n    x,\n    y,\n    scale,\n    style,\n    closed\n  ) {\n    var scalex, scaley, i, l, leg, x2, y2, x3, y3, x4, y4, tmp;\n\n    // Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)\n    // in effort to make all calls have similar signature like\n    //   function(content, coordinateX, coordinateY , miscellaneous)\n    // this method had its args flipped.\n    // code below allows backward compatibility with old arg order.\n    if (typeof lines === \"number\") {\n      tmp = y;\n      y = x;\n      x = lines;\n      lines = tmp;\n    }\n\n    scale = scale || [1, 1];\n    closed = closed || false;\n\n    if (\n      isNaN(x) ||\n      isNaN(y) ||\n      !Array.isArray(lines) ||\n      !Array.isArray(scale) ||\n      !isValidStyle(style) ||\n      typeof closed !== \"boolean\"\n    ) {\n      throw new Error(\"Invalid arguments passed to jsPDF.lines\");\n    }\n\n    // starting point\n    moveTo(x, y);\n\n    scalex = scale[0];\n    scaley = scale[1];\n    l = lines.length;\n    //, x2, y2 // bezier only. In page default measurement \"units\", *after* scaling\n    //, x3, y3 // bezier only. In page default measurement \"units\", *after* scaling\n    // ending point for all, lines and bezier. . In page default measurement \"units\", *after* scaling\n    x4 = x; // last / ending point = starting point for first item.\n    y4 = y; // last / ending point = starting point for first item.\n\n    for (i = 0; i < l; i++) {\n      leg = lines[i];\n      if (leg.length === 2) {\n        // simple line\n        x4 = leg[0] * scalex + x4; // here last x4 was prior ending point\n        y4 = leg[1] * scaley + y4; // here last y4 was prior ending point\n        lineTo(x4, y4);\n      } else {\n        // bezier curve\n        x2 = leg[0] * scalex + x4; // here last x4 is prior ending point\n        y2 = leg[1] * scaley + y4; // here last y4 is prior ending point\n        x3 = leg[2] * scalex + x4; // here last x4 is prior ending point\n        y3 = leg[3] * scaley + y4; // here last y4 is prior ending point\n        x4 = leg[4] * scalex + x4; // here last x4 was prior ending point\n        y4 = leg[5] * scaley + y4; // here last y4 was prior ending point\n        curveTo(x2, y2, x3, y3, x4, y4);\n      }\n    }\n\n    if (closed) {\n      close();\n    }\n\n    putStyle(style);\n    return this;\n  };\n\n  /**\n   * Similar to {@link API.lines} but all coordinates are interpreted as absolute coordinates instead of relative.\n   * @param {Array<Object>} lines An array of {op: operator, c: coordinates} object, where op is one of \"m\" (move to), \"l\" (line to)\n   * \"c\" (cubic bezier curve) and \"h\" (close (sub)path)). c is an array of coordinates. \"m\" and \"l\" expect two, \"c\"\n   * six and \"h\" an empty array (or undefined).\n   * @function\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @name path\n   */\n  API.path = function(lines) {\n    for (var i = 0; i < lines.length; i++) {\n      var leg = lines[i];\n      var coords = leg.c;\n      switch (leg.op) {\n        case \"m\":\n          moveTo(coords[0], coords[1]);\n          break;\n        case \"l\":\n          lineTo(coords[0], coords[1]);\n          break;\n        case \"c\":\n          curveTo.apply(this, coords);\n          break;\n        case \"h\":\n          close();\n          break;\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Adds a rectangle to PDF.\n   *\n   * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page\n   * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n   * @param {number} w Width (in units declared at inception of PDF document)\n   * @param {number} h Height (in units declared at inception of PDF document)\n   * @param {string=} style A string specifying the painting style or null. Valid styles include:\n   * 'S' [default] - stroke,\n   * 'F' - fill,\n   * and 'DF' (or 'FD') -  fill then stroke.\n   * In \"compat\" API mode, a null value postpones setting the style so that a shape may be composed using multiple\n   * method calls. The last drawing method call used to define the shape should not have a null style argument.\n   *\n   * In \"advanced\" API mode this parameter is deprecated.\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @name rect\n   */\n  API.__private__.rect = API.rect = function(x, y, w, h, style) {\n    if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h) || !isValidStyle(style)) {\n      throw new Error(\"Invalid arguments passed to jsPDF.rect\");\n    }\n    if (apiMode === ApiMode.COMPAT) {\n      h = -h;\n    }\n\n    out(\n      [\n        hpf(scale(x)),\n        hpf(transformScaleY(y)),\n        hpf(scale(w)),\n        hpf(scale(h)),\n        \"re\"\n      ].join(\" \")\n    );\n\n    putStyle(style);\n    return this;\n  };\n\n  /**\n   * Adds a triangle to PDF.\n   *\n   * @param {number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page\n   * @param {number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page\n   * @param {number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page\n   * @param {number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page\n   * @param {number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page\n   * @param {number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page\n   * @param {string=} style A string specifying the painting style or null. Valid styles include:\n   * 'S' [default] - stroke,\n   * 'F' - fill,\n   * and 'DF' (or 'FD') -  fill then stroke.\n   * In \"compat\" API mode, a null value postpones setting the style so that a shape may be composed using multiple\n   * method calls. The last drawing method call used to define the shape should not have a null style argument.\n   *\n   * In \"advanced\" API mode this parameter is deprecated.\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @name triangle\n   */\n  API.__private__.triangle = API.triangle = function(\n    x1,\n    y1,\n    x2,\n    y2,\n    x3,\n    y3,\n    style\n  ) {\n    if (\n      isNaN(x1) ||\n      isNaN(y1) ||\n      isNaN(x2) ||\n      isNaN(y2) ||\n      isNaN(x3) ||\n      isNaN(y3) ||\n      !isValidStyle(style)\n    ) {\n      throw new Error(\"Invalid arguments passed to jsPDF.triangle\");\n    }\n    this.lines(\n      [\n        [x2 - x1, y2 - y1], // vector to point 2\n        [x3 - x2, y3 - y2], // vector to point 3\n        [x1 - x3, y1 - y3] // closing vector back to point 1\n      ],\n      x1,\n      y1, // start of path\n      [1, 1],\n      style,\n      true\n    );\n    return this;\n  };\n\n  /**\n   * Adds a rectangle with rounded corners to PDF.\n   *\n   * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page\n   * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n   * @param {number} w Width (in units declared at inception of PDF document)\n   * @param {number} h Height (in units declared at inception of PDF document)\n   * @param {number} rx Radius along x axis (in units declared at inception of PDF document)\n   * @param {number} ry Radius along y axis (in units declared at inception of PDF document)\n   * @param {string=} style A string specifying the painting style or null. Valid styles include:\n   * 'S' [default] - stroke,\n   * 'F' - fill,\n   * and 'DF' (or 'FD') -  fill then stroke.\n   * In \"compat\" API mode, a null value postpones setting the style so that a shape may be composed using multiple\n   * method calls. The last drawing method call used to define the shape should not have a null style argument.\n   *\n   * In \"advanced\" API mode this parameter is deprecated.\n   * @function\n   * @instance\n   * @returns {jsPDF}\n   * @memberof jsPDF#\n   * @name roundedRect\n   */\n  API.__private__.roundedRect = API.roundedRect = function(\n    x,\n    y,\n    w,\n    h,\n    rx,\n    ry,\n    style\n  ) {\n    if (\n      isNaN(x) ||\n      isNaN(y) ||\n      isNaN(w) ||\n      isNaN(h) ||\n      isNaN(rx) ||\n      isNaN(ry) ||\n      !isValidStyle(style)\n    ) {\n      throw new Error(\"Invalid arguments passed to jsPDF.roundedRect\");\n    }\n    var MyArc = (4 / 3) * (Math.SQRT2 - 1);\n\n    rx = Math.min(rx, w * 0.5);\n    ry = Math.min(ry, h * 0.5);\n\n    this.lines(\n      [\n        [w - 2 * rx, 0],\n        [rx * MyArc, 0, rx, ry - ry * MyArc, rx, ry],\n        [0, h - 2 * ry],\n        [0, ry * MyArc, -(rx * MyArc), ry, -rx, ry],\n        [-w + 2 * rx, 0],\n        [-(rx * MyArc), 0, -rx, -(ry * MyArc), -rx, -ry],\n        [0, -h + 2 * ry],\n        [0, -(ry * MyArc), rx * MyArc, -ry, rx, -ry]\n      ],\n      x + rx,\n      y, // start of path\n      [1, 1],\n      style,\n      true\n    );\n    return this;\n  };\n\n  /**\n   * Adds an ellipse to PDF.\n   *\n   * @param {number} x Coordi